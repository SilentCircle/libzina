// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageEnvelope.proto

#ifndef PROTOBUF_MessageEnvelope_2eproto__INCLUDED
#define PROTOBUF_MessageEnvelope_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace zina {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MessageEnvelope_2eproto();
void protobuf_AssignDesc_MessageEnvelope_2eproto();
void protobuf_ShutdownFile_MessageEnvelope_2eproto();

class MessageEnvelope;
class RatchetData;

// ===================================================================

class MessageEnvelope : public ::google::protobuf::MessageLite {
 public:
  MessageEnvelope();
  virtual ~MessageEnvelope();

  MessageEnvelope(const MessageEnvelope& from);

  inline MessageEnvelope& operator=(const MessageEnvelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MessageEnvelope& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MessageEnvelope* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MessageEnvelope* other);

  // implements Message ----------------------------------------------

  MessageEnvelope* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MessageEnvelope& from);
  void MergeFrom(const MessageEnvelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string scClientDevId = 2;
  inline bool has_scclientdevid() const;
  inline void clear_scclientdevid();
  static const int kScClientDevIdFieldNumber = 2;
  inline const ::std::string& scclientdevid() const;
  inline void set_scclientdevid(const ::std::string& value);
  inline void set_scclientdevid(const char* value);
  inline void set_scclientdevid(const char* value, size_t size);
  inline ::std::string* mutable_scclientdevid();
  inline ::std::string* release_scclientdevid();
  inline void set_allocated_scclientdevid(::std::string* scclientdevid);

  // optional uint32 msgType = 3;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::google::protobuf::uint32 value);

  // optional bytes supplement = 4;
  inline bool has_supplement() const;
  inline void clear_supplement();
  static const int kSupplementFieldNumber = 4;
  inline const ::std::string& supplement() const;
  inline void set_supplement(const ::std::string& value);
  inline void set_supplement(const char* value);
  inline void set_supplement(const void* value, size_t size);
  inline ::std::string* mutable_supplement();
  inline ::std::string* release_supplement();
  inline void set_allocated_supplement(::std::string* supplement);

  // optional bytes message = 5;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 5;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional string msgId = 6;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIdFieldNumber = 6;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // optional bytes recvIdHash = 7;
  inline bool has_recvidhash() const;
  inline void clear_recvidhash();
  static const int kRecvIdHashFieldNumber = 7;
  inline const ::std::string& recvidhash() const;
  inline void set_recvidhash(const ::std::string& value);
  inline void set_recvidhash(const char* value);
  inline void set_recvidhash(const void* value, size_t size);
  inline ::std::string* mutable_recvidhash();
  inline ::std::string* release_recvidhash();
  inline void set_allocated_recvidhash(::std::string* recvidhash);

  // optional bytes senderIdHash = 8;
  inline bool has_senderidhash() const;
  inline void clear_senderidhash();
  static const int kSenderIdHashFieldNumber = 8;
  inline const ::std::string& senderidhash() const;
  inline void set_senderidhash(const ::std::string& value);
  inline void set_senderidhash(const char* value);
  inline void set_senderidhash(const void* value, size_t size);
  inline ::std::string* mutable_senderidhash();
  inline ::std::string* release_senderidhash();
  inline void set_allocated_senderidhash(::std::string* senderidhash);

  // optional bytes recvDevIdBin = 10;
  inline bool has_recvdevidbin() const;
  inline void clear_recvdevidbin();
  static const int kRecvDevIdBinFieldNumber = 10;
  inline const ::std::string& recvdevidbin() const;
  inline void set_recvdevidbin(const ::std::string& value);
  inline void set_recvdevidbin(const char* value);
  inline void set_recvdevidbin(const void* value, size_t size);
  inline ::std::string* mutable_recvdevidbin();
  inline ::std::string* release_recvdevidbin();
  inline void set_allocated_recvdevidbin(::std::string* recvdevidbin);

  // optional .zina.RatchetData ratchet = 12;
  inline bool has_ratchet() const;
  inline void clear_ratchet();
  static const int kRatchetFieldNumber = 12;
  inline const ::zina::RatchetData& ratchet() const;
  inline ::zina::RatchetData* mutable_ratchet();
  inline ::zina::RatchetData* release_ratchet();
  inline void set_allocated_ratchet(::zina::RatchetData* ratchet);

  // @@protoc_insertion_point(class_scope:zina.MessageEnvelope)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_scclientdevid();
  inline void clear_has_scclientdevid();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_supplement();
  inline void clear_has_supplement();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_recvidhash();
  inline void clear_has_recvidhash();
  inline void set_has_senderidhash();
  inline void clear_has_senderidhash();
  inline void set_has_recvdevidbin();
  inline void clear_has_recvdevidbin();
  inline void set_has_ratchet();
  inline void clear_has_ratchet();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* scclientdevid_;
  ::std::string* supplement_;
  ::std::string* message_;
  ::std::string* msgid_;
  ::std::string* recvidhash_;
  ::std::string* senderidhash_;
  ::std::string* recvdevidbin_;
  ::zina::RatchetData* ratchet_;
  ::google::protobuf::uint32 msgtype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MessageEnvelope_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MessageEnvelope_2eproto();
  #endif
  friend void protobuf_AssignDesc_MessageEnvelope_2eproto();
  friend void protobuf_ShutdownFile_MessageEnvelope_2eproto();

  void InitAsDefaultInstance();
  static MessageEnvelope* default_instance_;
};
// -------------------------------------------------------------------

class RatchetData : public ::google::protobuf::MessageLite {
 public:
  RatchetData();
  virtual ~RatchetData();

  RatchetData(const RatchetData& from);

  inline RatchetData& operator=(const RatchetData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RatchetData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RatchetData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RatchetData* other);

  // implements Message ----------------------------------------------

  RatchetData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RatchetData& from);
  void MergeFrom(const RatchetData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 useVersion = 1;
  inline bool has_useversion() const;
  inline void clear_useversion();
  static const int kUseVersionFieldNumber = 1;
  inline ::google::protobuf::int32 useversion() const;
  inline void set_useversion(::google::protobuf::int32 value);

  // optional int32 maxVersion = 2;
  inline bool has_maxversion() const;
  inline void clear_maxversion();
  static const int kMaxVersionFieldNumber = 2;
  inline ::google::protobuf::int32 maxversion() const;
  inline void set_maxversion(::google::protobuf::int32 value);

  // optional uint32 contextId = 3;
  inline bool has_contextid() const;
  inline void clear_contextid();
  static const int kContextIdFieldNumber = 3;
  inline ::google::protobuf::uint32 contextid() const;
  inline void set_contextid(::google::protobuf::uint32 value);

  // optional int32 curveType = 4;
  inline bool has_curvetype() const;
  inline void clear_curvetype();
  static const int kCurveTypeFieldNumber = 4;
  inline ::google::protobuf::int32 curvetype() const;
  inline void set_curvetype(::google::protobuf::int32 value);

  // optional uint32 flags = 5;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 5;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional int32 ratchetMsgType = 6;
  inline bool has_ratchetmsgtype() const;
  inline void clear_ratchetmsgtype();
  static const int kRatchetMsgTypeFieldNumber = 6;
  inline ::google::protobuf::int32 ratchetmsgtype() const;
  inline void set_ratchetmsgtype(::google::protobuf::int32 value);

  // optional int32 Np = 7;
  inline bool has_np() const;
  inline void clear_np();
  static const int kNpFieldNumber = 7;
  inline ::google::protobuf::int32 np() const;
  inline void set_np(::google::protobuf::int32 value);

  // optional int32 PNp = 8;
  inline bool has_pnp() const;
  inline void clear_pnp();
  static const int kPNpFieldNumber = 8;
  inline ::google::protobuf::int32 pnp() const;
  inline void set_pnp(::google::protobuf::int32 value);

  // optional bytes ratchet = 9;
  inline bool has_ratchet() const;
  inline void clear_ratchet();
  static const int kRatchetFieldNumber = 9;
  inline const ::std::string& ratchet() const;
  inline void set_ratchet(const ::std::string& value);
  inline void set_ratchet(const char* value);
  inline void set_ratchet(const void* value, size_t size);
  inline ::std::string* mutable_ratchet();
  inline ::std::string* release_ratchet();
  inline void set_allocated_ratchet(::std::string* ratchet);

  // optional bytes mac = 10;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 10;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const void* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional int32 localPreKeyId = 11;
  inline bool has_localprekeyid() const;
  inline void clear_localprekeyid();
  static const int kLocalPreKeyIdFieldNumber = 11;
  inline ::google::protobuf::int32 localprekeyid() const;
  inline void set_localprekeyid(::google::protobuf::int32 value);

  // optional bytes remotePreKey = 12;
  inline bool has_remoteprekey() const;
  inline void clear_remoteprekey();
  static const int kRemotePreKeyFieldNumber = 12;
  inline const ::std::string& remoteprekey() const;
  inline void set_remoteprekey(const ::std::string& value);
  inline void set_remoteprekey(const char* value);
  inline void set_remoteprekey(const void* value, size_t size);
  inline ::std::string* mutable_remoteprekey();
  inline ::std::string* release_remoteprekey();
  inline void set_allocated_remoteprekey(::std::string* remoteprekey);

  // optional bytes remoteIdKey = 13;
  inline bool has_remoteidkey() const;
  inline void clear_remoteidkey();
  static const int kRemoteIdKeyFieldNumber = 13;
  inline const ::std::string& remoteidkey() const;
  inline void set_remoteidkey(const ::std::string& value);
  inline void set_remoteidkey(const char* value);
  inline void set_remoteidkey(const void* value, size_t size);
  inline ::std::string* mutable_remoteidkey();
  inline ::std::string* release_remoteidkey();
  inline void set_allocated_remoteidkey(::std::string* remoteidkey);

  // optional bytes preKeyHash = 14;
  inline bool has_prekeyhash() const;
  inline void clear_prekeyhash();
  static const int kPreKeyHashFieldNumber = 14;
  inline const ::std::string& prekeyhash() const;
  inline void set_prekeyhash(const ::std::string& value);
  inline void set_prekeyhash(const char* value);
  inline void set_prekeyhash(const void* value, size_t size);
  inline ::std::string* mutable_prekeyhash();
  inline ::std::string* release_prekeyhash();
  inline void set_allocated_prekeyhash(::std::string* prekeyhash);

  // @@protoc_insertion_point(class_scope:zina.RatchetData)
 private:
  inline void set_has_useversion();
  inline void clear_has_useversion();
  inline void set_has_maxversion();
  inline void clear_has_maxversion();
  inline void set_has_contextid();
  inline void clear_has_contextid();
  inline void set_has_curvetype();
  inline void clear_has_curvetype();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_ratchetmsgtype();
  inline void clear_has_ratchetmsgtype();
  inline void set_has_np();
  inline void clear_has_np();
  inline void set_has_pnp();
  inline void clear_has_pnp();
  inline void set_has_ratchet();
  inline void clear_has_ratchet();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_localprekeyid();
  inline void clear_has_localprekeyid();
  inline void set_has_remoteprekey();
  inline void clear_has_remoteprekey();
  inline void set_has_remoteidkey();
  inline void clear_has_remoteidkey();
  inline void set_has_prekeyhash();
  inline void clear_has_prekeyhash();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 useversion_;
  ::google::protobuf::int32 maxversion_;
  ::google::protobuf::uint32 contextid_;
  ::google::protobuf::int32 curvetype_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::int32 ratchetmsgtype_;
  ::google::protobuf::int32 np_;
  ::google::protobuf::int32 pnp_;
  ::std::string* ratchet_;
  ::std::string* mac_;
  ::std::string* remoteprekey_;
  ::std::string* remoteidkey_;
  ::std::string* prekeyhash_;
  ::google::protobuf::int32 localprekeyid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MessageEnvelope_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MessageEnvelope_2eproto();
  #endif
  friend void protobuf_AssignDesc_MessageEnvelope_2eproto();
  friend void protobuf_ShutdownFile_MessageEnvelope_2eproto();

  void InitAsDefaultInstance();
  static RatchetData* default_instance_;
};
// ===================================================================


// ===================================================================

// MessageEnvelope

// optional string name = 1;
inline bool MessageEnvelope::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageEnvelope::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageEnvelope::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageEnvelope::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MessageEnvelope::name() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.name)
  return *name_;
}
inline void MessageEnvelope::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.name)
}
inline void MessageEnvelope::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.name)
}
inline void MessageEnvelope::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.name)
}
inline ::std::string* MessageEnvelope::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.name)
  return name_;
}
inline ::std::string* MessageEnvelope::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageEnvelope::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.name)
}

// optional string scClientDevId = 2;
inline bool MessageEnvelope::has_scclientdevid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageEnvelope::set_has_scclientdevid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageEnvelope::clear_has_scclientdevid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageEnvelope::clear_scclientdevid() {
  if (scclientdevid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scclientdevid_->clear();
  }
  clear_has_scclientdevid();
}
inline const ::std::string& MessageEnvelope::scclientdevid() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.scClientDevId)
  return *scclientdevid_;
}
inline void MessageEnvelope::set_scclientdevid(const ::std::string& value) {
  set_has_scclientdevid();
  if (scclientdevid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scclientdevid_ = new ::std::string;
  }
  scclientdevid_->assign(value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.scClientDevId)
}
inline void MessageEnvelope::set_scclientdevid(const char* value) {
  set_has_scclientdevid();
  if (scclientdevid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scclientdevid_ = new ::std::string;
  }
  scclientdevid_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.scClientDevId)
}
inline void MessageEnvelope::set_scclientdevid(const char* value, size_t size) {
  set_has_scclientdevid();
  if (scclientdevid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scclientdevid_ = new ::std::string;
  }
  scclientdevid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.scClientDevId)
}
inline ::std::string* MessageEnvelope::mutable_scclientdevid() {
  set_has_scclientdevid();
  if (scclientdevid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    scclientdevid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.scClientDevId)
  return scclientdevid_;
}
inline ::std::string* MessageEnvelope::release_scclientdevid() {
  clear_has_scclientdevid();
  if (scclientdevid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = scclientdevid_;
    scclientdevid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageEnvelope::set_allocated_scclientdevid(::std::string* scclientdevid) {
  if (scclientdevid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete scclientdevid_;
  }
  if (scclientdevid) {
    set_has_scclientdevid();
    scclientdevid_ = scclientdevid;
  } else {
    clear_has_scclientdevid();
    scclientdevid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.scClientDevId)
}

// optional uint32 msgType = 3;
inline bool MessageEnvelope::has_msgtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageEnvelope::set_has_msgtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageEnvelope::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageEnvelope::clear_msgtype() {
  msgtype_ = 0u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 MessageEnvelope::msgtype() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.msgType)
  return msgtype_;
}
inline void MessageEnvelope::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.msgType)
}

// optional bytes supplement = 4;
inline bool MessageEnvelope::has_supplement() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageEnvelope::set_has_supplement() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageEnvelope::clear_has_supplement() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageEnvelope::clear_supplement() {
  if (supplement_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supplement_->clear();
  }
  clear_has_supplement();
}
inline const ::std::string& MessageEnvelope::supplement() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.supplement)
  return *supplement_;
}
inline void MessageEnvelope::set_supplement(const ::std::string& value) {
  set_has_supplement();
  if (supplement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supplement_ = new ::std::string;
  }
  supplement_->assign(value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.supplement)
}
inline void MessageEnvelope::set_supplement(const char* value) {
  set_has_supplement();
  if (supplement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supplement_ = new ::std::string;
  }
  supplement_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.supplement)
}
inline void MessageEnvelope::set_supplement(const void* value, size_t size) {
  set_has_supplement();
  if (supplement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supplement_ = new ::std::string;
  }
  supplement_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.supplement)
}
inline ::std::string* MessageEnvelope::mutable_supplement() {
  set_has_supplement();
  if (supplement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supplement_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.supplement)
  return supplement_;
}
inline ::std::string* MessageEnvelope::release_supplement() {
  clear_has_supplement();
  if (supplement_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = supplement_;
    supplement_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageEnvelope::set_allocated_supplement(::std::string* supplement) {
  if (supplement_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete supplement_;
  }
  if (supplement) {
    set_has_supplement();
    supplement_ = supplement;
  } else {
    clear_has_supplement();
    supplement_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.supplement)
}

// optional bytes message = 5;
inline bool MessageEnvelope::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageEnvelope::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageEnvelope::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageEnvelope::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& MessageEnvelope::message() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.message)
  return *message_;
}
inline void MessageEnvelope::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.message)
}
inline void MessageEnvelope::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.message)
}
inline void MessageEnvelope::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.message)
}
inline ::std::string* MessageEnvelope::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.message)
  return message_;
}
inline ::std::string* MessageEnvelope::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageEnvelope::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.message)
}

// optional string msgId = 6;
inline bool MessageEnvelope::has_msgid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageEnvelope::set_has_msgid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageEnvelope::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageEnvelope::clear_msgid() {
  if (msgid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& MessageEnvelope::msgid() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.msgId)
  return *msgid_;
}
inline void MessageEnvelope::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.msgId)
}
inline void MessageEnvelope::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.msgId)
}
inline void MessageEnvelope::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.msgId)
}
inline ::std::string* MessageEnvelope::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.msgId)
  return msgid_;
}
inline ::std::string* MessageEnvelope::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageEnvelope::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.msgId)
}

// optional bytes recvIdHash = 7;
inline bool MessageEnvelope::has_recvidhash() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessageEnvelope::set_has_recvidhash() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessageEnvelope::clear_has_recvidhash() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessageEnvelope::clear_recvidhash() {
  if (recvidhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recvidhash_->clear();
  }
  clear_has_recvidhash();
}
inline const ::std::string& MessageEnvelope::recvidhash() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.recvIdHash)
  return *recvidhash_;
}
inline void MessageEnvelope::set_recvidhash(const ::std::string& value) {
  set_has_recvidhash();
  if (recvidhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recvidhash_ = new ::std::string;
  }
  recvidhash_->assign(value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.recvIdHash)
}
inline void MessageEnvelope::set_recvidhash(const char* value) {
  set_has_recvidhash();
  if (recvidhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recvidhash_ = new ::std::string;
  }
  recvidhash_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.recvIdHash)
}
inline void MessageEnvelope::set_recvidhash(const void* value, size_t size) {
  set_has_recvidhash();
  if (recvidhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recvidhash_ = new ::std::string;
  }
  recvidhash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.recvIdHash)
}
inline ::std::string* MessageEnvelope::mutable_recvidhash() {
  set_has_recvidhash();
  if (recvidhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recvidhash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.recvIdHash)
  return recvidhash_;
}
inline ::std::string* MessageEnvelope::release_recvidhash() {
  clear_has_recvidhash();
  if (recvidhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = recvidhash_;
    recvidhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageEnvelope::set_allocated_recvidhash(::std::string* recvidhash) {
  if (recvidhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete recvidhash_;
  }
  if (recvidhash) {
    set_has_recvidhash();
    recvidhash_ = recvidhash;
  } else {
    clear_has_recvidhash();
    recvidhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.recvIdHash)
}

// optional bytes senderIdHash = 8;
inline bool MessageEnvelope::has_senderidhash() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MessageEnvelope::set_has_senderidhash() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MessageEnvelope::clear_has_senderidhash() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MessageEnvelope::clear_senderidhash() {
  if (senderidhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    senderidhash_->clear();
  }
  clear_has_senderidhash();
}
inline const ::std::string& MessageEnvelope::senderidhash() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.senderIdHash)
  return *senderidhash_;
}
inline void MessageEnvelope::set_senderidhash(const ::std::string& value) {
  set_has_senderidhash();
  if (senderidhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    senderidhash_ = new ::std::string;
  }
  senderidhash_->assign(value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.senderIdHash)
}
inline void MessageEnvelope::set_senderidhash(const char* value) {
  set_has_senderidhash();
  if (senderidhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    senderidhash_ = new ::std::string;
  }
  senderidhash_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.senderIdHash)
}
inline void MessageEnvelope::set_senderidhash(const void* value, size_t size) {
  set_has_senderidhash();
  if (senderidhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    senderidhash_ = new ::std::string;
  }
  senderidhash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.senderIdHash)
}
inline ::std::string* MessageEnvelope::mutable_senderidhash() {
  set_has_senderidhash();
  if (senderidhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    senderidhash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.senderIdHash)
  return senderidhash_;
}
inline ::std::string* MessageEnvelope::release_senderidhash() {
  clear_has_senderidhash();
  if (senderidhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = senderidhash_;
    senderidhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageEnvelope::set_allocated_senderidhash(::std::string* senderidhash) {
  if (senderidhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete senderidhash_;
  }
  if (senderidhash) {
    set_has_senderidhash();
    senderidhash_ = senderidhash;
  } else {
    clear_has_senderidhash();
    senderidhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.senderIdHash)
}

// optional bytes recvDevIdBin = 10;
inline bool MessageEnvelope::has_recvdevidbin() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MessageEnvelope::set_has_recvdevidbin() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MessageEnvelope::clear_has_recvdevidbin() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MessageEnvelope::clear_recvdevidbin() {
  if (recvdevidbin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recvdevidbin_->clear();
  }
  clear_has_recvdevidbin();
}
inline const ::std::string& MessageEnvelope::recvdevidbin() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.recvDevIdBin)
  return *recvdevidbin_;
}
inline void MessageEnvelope::set_recvdevidbin(const ::std::string& value) {
  set_has_recvdevidbin();
  if (recvdevidbin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recvdevidbin_ = new ::std::string;
  }
  recvdevidbin_->assign(value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.recvDevIdBin)
}
inline void MessageEnvelope::set_recvdevidbin(const char* value) {
  set_has_recvdevidbin();
  if (recvdevidbin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recvdevidbin_ = new ::std::string;
  }
  recvdevidbin_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.recvDevIdBin)
}
inline void MessageEnvelope::set_recvdevidbin(const void* value, size_t size) {
  set_has_recvdevidbin();
  if (recvdevidbin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recvdevidbin_ = new ::std::string;
  }
  recvdevidbin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.recvDevIdBin)
}
inline ::std::string* MessageEnvelope::mutable_recvdevidbin() {
  set_has_recvdevidbin();
  if (recvdevidbin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recvdevidbin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.recvDevIdBin)
  return recvdevidbin_;
}
inline ::std::string* MessageEnvelope::release_recvdevidbin() {
  clear_has_recvdevidbin();
  if (recvdevidbin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = recvdevidbin_;
    recvdevidbin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageEnvelope::set_allocated_recvdevidbin(::std::string* recvdevidbin) {
  if (recvdevidbin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete recvdevidbin_;
  }
  if (recvdevidbin) {
    set_has_recvdevidbin();
    recvdevidbin_ = recvdevidbin;
  } else {
    clear_has_recvdevidbin();
    recvdevidbin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.recvDevIdBin)
}

// optional .zina.RatchetData ratchet = 12;
inline bool MessageEnvelope::has_ratchet() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MessageEnvelope::set_has_ratchet() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MessageEnvelope::clear_has_ratchet() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MessageEnvelope::clear_ratchet() {
  if (ratchet_ != NULL) ratchet_->::zina::RatchetData::Clear();
  clear_has_ratchet();
}
inline const ::zina::RatchetData& MessageEnvelope::ratchet() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.ratchet)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ratchet_ != NULL ? *ratchet_ : *default_instance().ratchet_;
#else
  return ratchet_ != NULL ? *ratchet_ : *default_instance_->ratchet_;
#endif
}
inline ::zina::RatchetData* MessageEnvelope::mutable_ratchet() {
  set_has_ratchet();
  if (ratchet_ == NULL) ratchet_ = new ::zina::RatchetData;
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.ratchet)
  return ratchet_;
}
inline ::zina::RatchetData* MessageEnvelope::release_ratchet() {
  clear_has_ratchet();
  ::zina::RatchetData* temp = ratchet_;
  ratchet_ = NULL;
  return temp;
}
inline void MessageEnvelope::set_allocated_ratchet(::zina::RatchetData* ratchet) {
  delete ratchet_;
  ratchet_ = ratchet;
  if (ratchet) {
    set_has_ratchet();
  } else {
    clear_has_ratchet();
  }
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.ratchet)
}

// -------------------------------------------------------------------

// RatchetData

// optional int32 useVersion = 1;
inline bool RatchetData::has_useversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RatchetData::set_has_useversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RatchetData::clear_has_useversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RatchetData::clear_useversion() {
  useversion_ = 0;
  clear_has_useversion();
}
inline ::google::protobuf::int32 RatchetData::useversion() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.useVersion)
  return useversion_;
}
inline void RatchetData::set_useversion(::google::protobuf::int32 value) {
  set_has_useversion();
  useversion_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.useVersion)
}

// optional int32 maxVersion = 2;
inline bool RatchetData::has_maxversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RatchetData::set_has_maxversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RatchetData::clear_has_maxversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RatchetData::clear_maxversion() {
  maxversion_ = 0;
  clear_has_maxversion();
}
inline ::google::protobuf::int32 RatchetData::maxversion() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.maxVersion)
  return maxversion_;
}
inline void RatchetData::set_maxversion(::google::protobuf::int32 value) {
  set_has_maxversion();
  maxversion_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.maxVersion)
}

// optional uint32 contextId = 3;
inline bool RatchetData::has_contextid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RatchetData::set_has_contextid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RatchetData::clear_has_contextid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RatchetData::clear_contextid() {
  contextid_ = 0u;
  clear_has_contextid();
}
inline ::google::protobuf::uint32 RatchetData::contextid() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.contextId)
  return contextid_;
}
inline void RatchetData::set_contextid(::google::protobuf::uint32 value) {
  set_has_contextid();
  contextid_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.contextId)
}

// optional int32 curveType = 4;
inline bool RatchetData::has_curvetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RatchetData::set_has_curvetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RatchetData::clear_has_curvetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RatchetData::clear_curvetype() {
  curvetype_ = 0;
  clear_has_curvetype();
}
inline ::google::protobuf::int32 RatchetData::curvetype() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.curveType)
  return curvetype_;
}
inline void RatchetData::set_curvetype(::google::protobuf::int32 value) {
  set_has_curvetype();
  curvetype_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.curveType)
}

// optional uint32 flags = 5;
inline bool RatchetData::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RatchetData::set_has_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RatchetData::clear_has_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RatchetData::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 RatchetData::flags() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.flags)
  return flags_;
}
inline void RatchetData::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.flags)
}

// optional int32 ratchetMsgType = 6;
inline bool RatchetData::has_ratchetmsgtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RatchetData::set_has_ratchetmsgtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RatchetData::clear_has_ratchetmsgtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RatchetData::clear_ratchetmsgtype() {
  ratchetmsgtype_ = 0;
  clear_has_ratchetmsgtype();
}
inline ::google::protobuf::int32 RatchetData::ratchetmsgtype() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.ratchetMsgType)
  return ratchetmsgtype_;
}
inline void RatchetData::set_ratchetmsgtype(::google::protobuf::int32 value) {
  set_has_ratchetmsgtype();
  ratchetmsgtype_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.ratchetMsgType)
}

// optional int32 Np = 7;
inline bool RatchetData::has_np() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RatchetData::set_has_np() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RatchetData::clear_has_np() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RatchetData::clear_np() {
  np_ = 0;
  clear_has_np();
}
inline ::google::protobuf::int32 RatchetData::np() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.Np)
  return np_;
}
inline void RatchetData::set_np(::google::protobuf::int32 value) {
  set_has_np();
  np_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.Np)
}

// optional int32 PNp = 8;
inline bool RatchetData::has_pnp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RatchetData::set_has_pnp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RatchetData::clear_has_pnp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RatchetData::clear_pnp() {
  pnp_ = 0;
  clear_has_pnp();
}
inline ::google::protobuf::int32 RatchetData::pnp() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.PNp)
  return pnp_;
}
inline void RatchetData::set_pnp(::google::protobuf::int32 value) {
  set_has_pnp();
  pnp_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.PNp)
}

// optional bytes ratchet = 9;
inline bool RatchetData::has_ratchet() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RatchetData::set_has_ratchet() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RatchetData::clear_has_ratchet() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RatchetData::clear_ratchet() {
  if (ratchet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ratchet_->clear();
  }
  clear_has_ratchet();
}
inline const ::std::string& RatchetData::ratchet() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.ratchet)
  return *ratchet_;
}
inline void RatchetData::set_ratchet(const ::std::string& value) {
  set_has_ratchet();
  if (ratchet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ratchet_ = new ::std::string;
  }
  ratchet_->assign(value);
  // @@protoc_insertion_point(field_set:zina.RatchetData.ratchet)
}
inline void RatchetData::set_ratchet(const char* value) {
  set_has_ratchet();
  if (ratchet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ratchet_ = new ::std::string;
  }
  ratchet_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.RatchetData.ratchet)
}
inline void RatchetData::set_ratchet(const void* value, size_t size) {
  set_has_ratchet();
  if (ratchet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ratchet_ = new ::std::string;
  }
  ratchet_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.RatchetData.ratchet)
}
inline ::std::string* RatchetData::mutable_ratchet() {
  set_has_ratchet();
  if (ratchet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ratchet_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.RatchetData.ratchet)
  return ratchet_;
}
inline ::std::string* RatchetData::release_ratchet() {
  clear_has_ratchet();
  if (ratchet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ratchet_;
    ratchet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RatchetData::set_allocated_ratchet(::std::string* ratchet) {
  if (ratchet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ratchet_;
  }
  if (ratchet) {
    set_has_ratchet();
    ratchet_ = ratchet;
  } else {
    clear_has_ratchet();
    ratchet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.RatchetData.ratchet)
}

// optional bytes mac = 10;
inline bool RatchetData::has_mac() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RatchetData::set_has_mac() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RatchetData::clear_has_mac() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RatchetData::clear_mac() {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& RatchetData::mac() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.mac)
  return *mac_;
}
inline void RatchetData::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set:zina.RatchetData.mac)
}
inline void RatchetData::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.RatchetData.mac)
}
inline void RatchetData::set_mac(const void* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.RatchetData.mac)
}
inline ::std::string* RatchetData::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.RatchetData.mac)
  return mac_;
}
inline ::std::string* RatchetData::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RatchetData::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.RatchetData.mac)
}

// optional int32 localPreKeyId = 11;
inline bool RatchetData::has_localprekeyid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RatchetData::set_has_localprekeyid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RatchetData::clear_has_localprekeyid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RatchetData::clear_localprekeyid() {
  localprekeyid_ = 0;
  clear_has_localprekeyid();
}
inline ::google::protobuf::int32 RatchetData::localprekeyid() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.localPreKeyId)
  return localprekeyid_;
}
inline void RatchetData::set_localprekeyid(::google::protobuf::int32 value) {
  set_has_localprekeyid();
  localprekeyid_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.localPreKeyId)
}

// optional bytes remotePreKey = 12;
inline bool RatchetData::has_remoteprekey() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RatchetData::set_has_remoteprekey() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RatchetData::clear_has_remoteprekey() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RatchetData::clear_remoteprekey() {
  if (remoteprekey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteprekey_->clear();
  }
  clear_has_remoteprekey();
}
inline const ::std::string& RatchetData::remoteprekey() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.remotePreKey)
  return *remoteprekey_;
}
inline void RatchetData::set_remoteprekey(const ::std::string& value) {
  set_has_remoteprekey();
  if (remoteprekey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteprekey_ = new ::std::string;
  }
  remoteprekey_->assign(value);
  // @@protoc_insertion_point(field_set:zina.RatchetData.remotePreKey)
}
inline void RatchetData::set_remoteprekey(const char* value) {
  set_has_remoteprekey();
  if (remoteprekey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteprekey_ = new ::std::string;
  }
  remoteprekey_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.RatchetData.remotePreKey)
}
inline void RatchetData::set_remoteprekey(const void* value, size_t size) {
  set_has_remoteprekey();
  if (remoteprekey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteprekey_ = new ::std::string;
  }
  remoteprekey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.RatchetData.remotePreKey)
}
inline ::std::string* RatchetData::mutable_remoteprekey() {
  set_has_remoteprekey();
  if (remoteprekey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteprekey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.RatchetData.remotePreKey)
  return remoteprekey_;
}
inline ::std::string* RatchetData::release_remoteprekey() {
  clear_has_remoteprekey();
  if (remoteprekey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remoteprekey_;
    remoteprekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RatchetData::set_allocated_remoteprekey(::std::string* remoteprekey) {
  if (remoteprekey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remoteprekey_;
  }
  if (remoteprekey) {
    set_has_remoteprekey();
    remoteprekey_ = remoteprekey;
  } else {
    clear_has_remoteprekey();
    remoteprekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.RatchetData.remotePreKey)
}

// optional bytes remoteIdKey = 13;
inline bool RatchetData::has_remoteidkey() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RatchetData::set_has_remoteidkey() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RatchetData::clear_has_remoteidkey() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RatchetData::clear_remoteidkey() {
  if (remoteidkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteidkey_->clear();
  }
  clear_has_remoteidkey();
}
inline const ::std::string& RatchetData::remoteidkey() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.remoteIdKey)
  return *remoteidkey_;
}
inline void RatchetData::set_remoteidkey(const ::std::string& value) {
  set_has_remoteidkey();
  if (remoteidkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteidkey_ = new ::std::string;
  }
  remoteidkey_->assign(value);
  // @@protoc_insertion_point(field_set:zina.RatchetData.remoteIdKey)
}
inline void RatchetData::set_remoteidkey(const char* value) {
  set_has_remoteidkey();
  if (remoteidkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteidkey_ = new ::std::string;
  }
  remoteidkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.RatchetData.remoteIdKey)
}
inline void RatchetData::set_remoteidkey(const void* value, size_t size) {
  set_has_remoteidkey();
  if (remoteidkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteidkey_ = new ::std::string;
  }
  remoteidkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.RatchetData.remoteIdKey)
}
inline ::std::string* RatchetData::mutable_remoteidkey() {
  set_has_remoteidkey();
  if (remoteidkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remoteidkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.RatchetData.remoteIdKey)
  return remoteidkey_;
}
inline ::std::string* RatchetData::release_remoteidkey() {
  clear_has_remoteidkey();
  if (remoteidkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remoteidkey_;
    remoteidkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RatchetData::set_allocated_remoteidkey(::std::string* remoteidkey) {
  if (remoteidkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remoteidkey_;
  }
  if (remoteidkey) {
    set_has_remoteidkey();
    remoteidkey_ = remoteidkey;
  } else {
    clear_has_remoteidkey();
    remoteidkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.RatchetData.remoteIdKey)
}

// optional bytes preKeyHash = 14;
inline bool RatchetData::has_prekeyhash() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RatchetData::set_has_prekeyhash() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RatchetData::clear_has_prekeyhash() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RatchetData::clear_prekeyhash() {
  if (prekeyhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prekeyhash_->clear();
  }
  clear_has_prekeyhash();
}
inline const ::std::string& RatchetData::prekeyhash() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.preKeyHash)
  return *prekeyhash_;
}
inline void RatchetData::set_prekeyhash(const ::std::string& value) {
  set_has_prekeyhash();
  if (prekeyhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prekeyhash_ = new ::std::string;
  }
  prekeyhash_->assign(value);
  // @@protoc_insertion_point(field_set:zina.RatchetData.preKeyHash)
}
inline void RatchetData::set_prekeyhash(const char* value) {
  set_has_prekeyhash();
  if (prekeyhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prekeyhash_ = new ::std::string;
  }
  prekeyhash_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.RatchetData.preKeyHash)
}
inline void RatchetData::set_prekeyhash(const void* value, size_t size) {
  set_has_prekeyhash();
  if (prekeyhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prekeyhash_ = new ::std::string;
  }
  prekeyhash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.RatchetData.preKeyHash)
}
inline ::std::string* RatchetData::mutable_prekeyhash() {
  set_has_prekeyhash();
  if (prekeyhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prekeyhash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.RatchetData.preKeyHash)
  return prekeyhash_;
}
inline ::std::string* RatchetData::release_prekeyhash() {
  clear_has_prekeyhash();
  if (prekeyhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = prekeyhash_;
    prekeyhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RatchetData::set_allocated_prekeyhash(::std::string* prekeyhash) {
  if (prekeyhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prekeyhash_;
  }
  if (prekeyhash) {
    set_has_prekeyhash();
    prekeyhash_ = prekeyhash;
  } else {
    clear_has_prekeyhash();
    prekeyhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.RatchetData.preKeyHash)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace zina

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MessageEnvelope_2eproto__INCLUDED
