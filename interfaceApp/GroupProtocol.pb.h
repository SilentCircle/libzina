// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GroupProtocol.proto

#ifndef PROTOBUF_GroupProtocol_2eproto__INCLUDED
#define PROTOBUF_GroupProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace zina {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GroupProtocol_2eproto();
void protobuf_AssignDesc_GroupProtocol_2eproto();
void protobuf_ShutdownFile_GroupProtocol_2eproto();

class VClock;
class LocalVClock;
class Member;
class GroupUpdateSetName;
class GroupUpdateSetAvatar;
class GroupUpdateSetBurn;
class GroupUpdateAddMember;
class GroupUpdateRmMember;
class GroupBurnMessage;
class GroupUpdateAck;
class GroupChangeSet;

enum GroupUpdateSetBurn_BurnMode {
  GroupUpdateSetBurn_BurnMode_BURN_NONE = 0,
  GroupUpdateSetBurn_BurnMode_FROM_SEND_RETROACTIVE = 1
};
bool GroupUpdateSetBurn_BurnMode_IsValid(int value);
const GroupUpdateSetBurn_BurnMode GroupUpdateSetBurn_BurnMode_BurnMode_MIN = GroupUpdateSetBurn_BurnMode_BURN_NONE;
const GroupUpdateSetBurn_BurnMode GroupUpdateSetBurn_BurnMode_BurnMode_MAX = GroupUpdateSetBurn_BurnMode_FROM_SEND_RETROACTIVE;
const int GroupUpdateSetBurn_BurnMode_BurnMode_ARRAYSIZE = GroupUpdateSetBurn_BurnMode_BurnMode_MAX + 1;

enum GroupUpdateType {
  TYPE_NONE = 0,
  GROUP_SET_NAME = 1,
  GROUP_SET_AVATAR = 2,
  GROUP_SET_BURN = 3,
  GROUP_ADD_MEMBER = 4,
  GROUP_REMOVE_MEMBER = 5,
  GROUP_BURN_MESSSAGE = 6
};
bool GroupUpdateType_IsValid(int value);
const GroupUpdateType GroupUpdateType_MIN = TYPE_NONE;
const GroupUpdateType GroupUpdateType_MAX = GROUP_BURN_MESSSAGE;
const int GroupUpdateType_ARRAYSIZE = GroupUpdateType_MAX + 1;

enum GroupUpdateResult {
  RESULT_NONE = 0,
  ACCEPTED_OK = 1,
  ACCEPTED_CONFLICT = 2,
  REJECTED_NOP = 3,
  REJECTED_PAST = 4,
  REJECTED_CONFLICT = 5
};
bool GroupUpdateResult_IsValid(int value);
const GroupUpdateResult GroupUpdateResult_MIN = RESULT_NONE;
const GroupUpdateResult GroupUpdateResult_MAX = REJECTED_CONFLICT;
const int GroupUpdateResult_ARRAYSIZE = GroupUpdateResult_MAX + 1;

// ===================================================================

class VClock : public ::google::protobuf::MessageLite {
 public:
  VClock();
  virtual ~VClock();

  VClock(const VClock& from);

  inline VClock& operator=(const VClock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const VClock& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VClock* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VClock* other);

  // implements Message ----------------------------------------------

  VClock* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VClock& from);
  void MergeFrom(const VClock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const void* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int64 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:zina.VClock)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* device_id_;
  ::google::protobuf::int64 value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static VClock* default_instance_;
};
// -------------------------------------------------------------------

class LocalVClock : public ::google::protobuf::MessageLite {
 public:
  LocalVClock();
  virtual ~LocalVClock();

  LocalVClock(const LocalVClock& from);

  inline LocalVClock& operator=(const LocalVClock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LocalVClock& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocalVClock* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocalVClock* other);

  // implements Message ----------------------------------------------

  LocalVClock* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocalVClock& from);
  void MergeFrom(const LocalVClock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zina.VClock vclock = 1;
  inline int vclock_size() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 1;
  inline const ::zina::VClock& vclock(int index) const;
  inline ::zina::VClock* mutable_vclock(int index);
  inline ::zina::VClock* add_vclock();
  inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
      vclock() const;
  inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
      mutable_vclock();

  // optional bytes update_id = 2;
  inline bool has_update_id() const;
  inline void clear_update_id();
  static const int kUpdateIdFieldNumber = 2;
  inline const ::std::string& update_id() const;
  inline void set_update_id(const ::std::string& value);
  inline void set_update_id(const char* value);
  inline void set_update_id(const void* value, size_t size);
  inline ::std::string* mutable_update_id();
  inline ::std::string* release_update_id();
  inline void set_allocated_update_id(::std::string* update_id);

  // @@protoc_insertion_point(class_scope:zina.LocalVClock)
 private:
  inline void set_has_update_id();
  inline void clear_has_update_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zina::VClock > vclock_;
  ::std::string* update_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static LocalVClock* default_instance_;
};
// -------------------------------------------------------------------

class Member : public ::google::protobuf::MessageLite {
 public:
  Member();
  virtual ~Member();

  Member(const Member& from);

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Member& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Member* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Member* other);

  // implements Message ----------------------------------------------

  Member* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Member& from);
  void MergeFrom(const Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:zina.Member)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static Member* default_instance_;
};
// -------------------------------------------------------------------

class GroupUpdateSetName : public ::google::protobuf::MessageLite {
 public:
  GroupUpdateSetName();
  virtual ~GroupUpdateSetName();

  GroupUpdateSetName(const GroupUpdateSetName& from);

  inline GroupUpdateSetName& operator=(const GroupUpdateSetName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupUpdateSetName& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupUpdateSetName* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupUpdateSetName* other);

  // implements Message ----------------------------------------------

  GroupUpdateSetName* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupUpdateSetName& from);
  void MergeFrom(const GroupUpdateSetName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes update_id = 1;
  inline bool has_update_id() const;
  inline void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  inline const ::std::string& update_id() const;
  inline void set_update_id(const ::std::string& value);
  inline void set_update_id(const char* value);
  inline void set_update_id(const void* value, size_t size);
  inline ::std::string* mutable_update_id();
  inline ::std::string* release_update_id();
  inline void set_allocated_update_id(::std::string* update_id);

  // repeated .zina.VClock vclock = 2;
  inline int vclock_size() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::zina::VClock& vclock(int index) const;
  inline ::zina::VClock* mutable_vclock(int index);
  inline ::zina::VClock* add_vclock();
  inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
      vclock() const;
  inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
      mutable_vclock();

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateSetName)
 private:
  inline void set_has_update_id();
  inline void clear_has_update_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* update_id_;
  ::google::protobuf::RepeatedPtrField< ::zina::VClock > vclock_;
  ::std::string* name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static GroupUpdateSetName* default_instance_;
};
// -------------------------------------------------------------------

class GroupUpdateSetAvatar : public ::google::protobuf::MessageLite {
 public:
  GroupUpdateSetAvatar();
  virtual ~GroupUpdateSetAvatar();

  GroupUpdateSetAvatar(const GroupUpdateSetAvatar& from);

  inline GroupUpdateSetAvatar& operator=(const GroupUpdateSetAvatar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupUpdateSetAvatar& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupUpdateSetAvatar* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupUpdateSetAvatar* other);

  // implements Message ----------------------------------------------

  GroupUpdateSetAvatar* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupUpdateSetAvatar& from);
  void MergeFrom(const GroupUpdateSetAvatar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes update_id = 1;
  inline bool has_update_id() const;
  inline void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  inline const ::std::string& update_id() const;
  inline void set_update_id(const ::std::string& value);
  inline void set_update_id(const char* value);
  inline void set_update_id(const void* value, size_t size);
  inline ::std::string* mutable_update_id();
  inline ::std::string* release_update_id();
  inline void set_allocated_update_id(::std::string* update_id);

  // repeated .zina.VClock vclock = 2;
  inline int vclock_size() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::zina::VClock& vclock(int index) const;
  inline ::zina::VClock* mutable_vclock(int index);
  inline ::zina::VClock* add_vclock();
  inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
      vclock() const;
  inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
      mutable_vclock();

  // optional string avatar = 3;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 3;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateSetAvatar)
 private:
  inline void set_has_update_id();
  inline void clear_has_update_id();
  inline void set_has_avatar();
  inline void clear_has_avatar();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* update_id_;
  ::google::protobuf::RepeatedPtrField< ::zina::VClock > vclock_;
  ::std::string* avatar_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static GroupUpdateSetAvatar* default_instance_;
};
// -------------------------------------------------------------------

class GroupUpdateSetBurn : public ::google::protobuf::MessageLite {
 public:
  GroupUpdateSetBurn();
  virtual ~GroupUpdateSetBurn();

  GroupUpdateSetBurn(const GroupUpdateSetBurn& from);

  inline GroupUpdateSetBurn& operator=(const GroupUpdateSetBurn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupUpdateSetBurn& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupUpdateSetBurn* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupUpdateSetBurn* other);

  // implements Message ----------------------------------------------

  GroupUpdateSetBurn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupUpdateSetBurn& from);
  void MergeFrom(const GroupUpdateSetBurn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GroupUpdateSetBurn_BurnMode BurnMode;
  static const BurnMode BURN_NONE = GroupUpdateSetBurn_BurnMode_BURN_NONE;
  static const BurnMode FROM_SEND_RETROACTIVE = GroupUpdateSetBurn_BurnMode_FROM_SEND_RETROACTIVE;
  static inline bool BurnMode_IsValid(int value) {
    return GroupUpdateSetBurn_BurnMode_IsValid(value);
  }
  static const BurnMode BurnMode_MIN =
    GroupUpdateSetBurn_BurnMode_BurnMode_MIN;
  static const BurnMode BurnMode_MAX =
    GroupUpdateSetBurn_BurnMode_BurnMode_MAX;
  static const int BurnMode_ARRAYSIZE =
    GroupUpdateSetBurn_BurnMode_BurnMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bytes update_id = 1;
  inline bool has_update_id() const;
  inline void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  inline const ::std::string& update_id() const;
  inline void set_update_id(const ::std::string& value);
  inline void set_update_id(const char* value);
  inline void set_update_id(const void* value, size_t size);
  inline ::std::string* mutable_update_id();
  inline ::std::string* release_update_id();
  inline void set_allocated_update_id(::std::string* update_id);

  // repeated .zina.VClock vclock = 2;
  inline int vclock_size() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::zina::VClock& vclock(int index) const;
  inline ::zina::VClock* mutable_vclock(int index);
  inline ::zina::VClock* add_vclock();
  inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
      vclock() const;
  inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
      mutable_vclock();

  // optional .zina.GroupUpdateSetBurn.BurnMode burn_mode = 3;
  inline bool has_burn_mode() const;
  inline void clear_burn_mode();
  static const int kBurnModeFieldNumber = 3;
  inline ::zina::GroupUpdateSetBurn_BurnMode burn_mode() const;
  inline void set_burn_mode(::zina::GroupUpdateSetBurn_BurnMode value);

  // optional uint64 burn_ttl_sec = 4;
  inline bool has_burn_ttl_sec() const;
  inline void clear_burn_ttl_sec();
  static const int kBurnTtlSecFieldNumber = 4;
  inline ::google::protobuf::uint64 burn_ttl_sec() const;
  inline void set_burn_ttl_sec(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateSetBurn)
 private:
  inline void set_has_update_id();
  inline void clear_has_update_id();
  inline void set_has_burn_mode();
  inline void clear_has_burn_mode();
  inline void set_has_burn_ttl_sec();
  inline void clear_has_burn_ttl_sec();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* update_id_;
  ::google::protobuf::RepeatedPtrField< ::zina::VClock > vclock_;
  ::google::protobuf::uint64 burn_ttl_sec_;
  int burn_mode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static GroupUpdateSetBurn* default_instance_;
};
// -------------------------------------------------------------------

class GroupUpdateAddMember : public ::google::protobuf::MessageLite {
 public:
  GroupUpdateAddMember();
  virtual ~GroupUpdateAddMember();

  GroupUpdateAddMember(const GroupUpdateAddMember& from);

  inline GroupUpdateAddMember& operator=(const GroupUpdateAddMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupUpdateAddMember& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupUpdateAddMember* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupUpdateAddMember* other);

  // implements Message ----------------------------------------------

  GroupUpdateAddMember* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupUpdateAddMember& from);
  void MergeFrom(const GroupUpdateAddMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes update_id = 1;
  inline bool has_update_id() const;
  inline void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  inline const ::std::string& update_id() const;
  inline void set_update_id(const ::std::string& value);
  inline void set_update_id(const char* value);
  inline void set_update_id(const void* value, size_t size);
  inline ::std::string* mutable_update_id();
  inline ::std::string* release_update_id();
  inline void set_allocated_update_id(::std::string* update_id);

  // repeated .zina.Member addMember = 2;
  inline int addmember_size() const;
  inline void clear_addmember();
  static const int kAddMemberFieldNumber = 2;
  inline const ::zina::Member& addmember(int index) const;
  inline ::zina::Member* mutable_addmember(int index);
  inline ::zina::Member* add_addmember();
  inline const ::google::protobuf::RepeatedPtrField< ::zina::Member >&
      addmember() const;
  inline ::google::protobuf::RepeatedPtrField< ::zina::Member >*
      mutable_addmember();

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateAddMember)
 private:
  inline void set_has_update_id();
  inline void clear_has_update_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* update_id_;
  ::google::protobuf::RepeatedPtrField< ::zina::Member > addmember_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static GroupUpdateAddMember* default_instance_;
};
// -------------------------------------------------------------------

class GroupUpdateRmMember : public ::google::protobuf::MessageLite {
 public:
  GroupUpdateRmMember();
  virtual ~GroupUpdateRmMember();

  GroupUpdateRmMember(const GroupUpdateRmMember& from);

  inline GroupUpdateRmMember& operator=(const GroupUpdateRmMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupUpdateRmMember& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupUpdateRmMember* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupUpdateRmMember* other);

  // implements Message ----------------------------------------------

  GroupUpdateRmMember* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupUpdateRmMember& from);
  void MergeFrom(const GroupUpdateRmMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes update_id = 1;
  inline bool has_update_id() const;
  inline void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  inline const ::std::string& update_id() const;
  inline void set_update_id(const ::std::string& value);
  inline void set_update_id(const char* value);
  inline void set_update_id(const void* value, size_t size);
  inline ::std::string* mutable_update_id();
  inline ::std::string* release_update_id();
  inline void set_allocated_update_id(::std::string* update_id);

  // repeated .zina.Member rmMember = 2;
  inline int rmmember_size() const;
  inline void clear_rmmember();
  static const int kRmMemberFieldNumber = 2;
  inline const ::zina::Member& rmmember(int index) const;
  inline ::zina::Member* mutable_rmmember(int index);
  inline ::zina::Member* add_rmmember();
  inline const ::google::protobuf::RepeatedPtrField< ::zina::Member >&
      rmmember() const;
  inline ::google::protobuf::RepeatedPtrField< ::zina::Member >*
      mutable_rmmember();

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateRmMember)
 private:
  inline void set_has_update_id();
  inline void clear_has_update_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* update_id_;
  ::google::protobuf::RepeatedPtrField< ::zina::Member > rmmember_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static GroupUpdateRmMember* default_instance_;
};
// -------------------------------------------------------------------

class GroupBurnMessage : public ::google::protobuf::MessageLite {
 public:
  GroupBurnMessage();
  virtual ~GroupBurnMessage();

  GroupBurnMessage(const GroupBurnMessage& from);

  inline GroupBurnMessage& operator=(const GroupBurnMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupBurnMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupBurnMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupBurnMessage* other);

  // implements Message ----------------------------------------------

  GroupBurnMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupBurnMessage& from);
  void MergeFrom(const GroupBurnMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes update_id = 1;
  inline bool has_update_id() const;
  inline void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  inline const ::std::string& update_id() const;
  inline void set_update_id(const ::std::string& value);
  inline void set_update_id(const char* value);
  inline void set_update_id(const void* value, size_t size);
  inline ::std::string* mutable_update_id();
  inline ::std::string* release_update_id();
  inline void set_allocated_update_id(::std::string* update_id);

  // repeated string msgId = 2;
  inline int msgid_size() const;
  inline void clear_msgid();
  static const int kMsgIdFieldNumber = 2;
  inline const ::std::string& msgid(int index) const;
  inline ::std::string* mutable_msgid(int index);
  inline void set_msgid(int index, const ::std::string& value);
  inline void set_msgid(int index, const char* value);
  inline void set_msgid(int index, const char* value, size_t size);
  inline ::std::string* add_msgid();
  inline void add_msgid(const ::std::string& value);
  inline void add_msgid(const char* value);
  inline void add_msgid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& msgid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_msgid();

  // optional .zina.Member member = 3;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 3;
  inline const ::zina::Member& member() const;
  inline ::zina::Member* mutable_member();
  inline ::zina::Member* release_member();
  inline void set_allocated_member(::zina::Member* member);

  // @@protoc_insertion_point(class_scope:zina.GroupBurnMessage)
 private:
  inline void set_has_update_id();
  inline void clear_has_update_id();
  inline void set_has_member();
  inline void clear_has_member();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* update_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> msgid_;
  ::zina::Member* member_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static GroupBurnMessage* default_instance_;
};
// -------------------------------------------------------------------

class GroupUpdateAck : public ::google::protobuf::MessageLite {
 public:
  GroupUpdateAck();
  virtual ~GroupUpdateAck();

  GroupUpdateAck(const GroupUpdateAck& from);

  inline GroupUpdateAck& operator=(const GroupUpdateAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupUpdateAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupUpdateAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupUpdateAck* other);

  // implements Message ----------------------------------------------

  GroupUpdateAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupUpdateAck& from);
  void MergeFrom(const GroupUpdateAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zina.GroupUpdateType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::zina::GroupUpdateType type() const;
  inline void set_type(::zina::GroupUpdateType value);

  // optional bytes update_id = 2;
  inline bool has_update_id() const;
  inline void clear_update_id();
  static const int kUpdateIdFieldNumber = 2;
  inline const ::std::string& update_id() const;
  inline void set_update_id(const ::std::string& value);
  inline void set_update_id(const char* value);
  inline void set_update_id(const void* value, size_t size);
  inline ::std::string* mutable_update_id();
  inline ::std::string* release_update_id();
  inline void set_allocated_update_id(::std::string* update_id);

  // optional .zina.GroupUpdateResult result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::zina::GroupUpdateResult result() const;
  inline void set_result(::zina::GroupUpdateResult value);

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateAck)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_update_id();
  inline void clear_has_update_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* update_id_;
  int type_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static GroupUpdateAck* default_instance_;
};
// -------------------------------------------------------------------

class GroupChangeSet : public ::google::protobuf::MessageLite {
 public:
  GroupChangeSet();
  virtual ~GroupChangeSet();

  GroupChangeSet(const GroupChangeSet& from);

  inline GroupChangeSet& operator=(const GroupChangeSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupChangeSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupChangeSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupChangeSet* other);

  // implements Message ----------------------------------------------

  GroupChangeSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupChangeSet& from);
  void MergeFrom(const GroupChangeSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::std::string& group_id() const;
  inline void set_group_id(const ::std::string& value);
  inline void set_group_id(const char* value);
  inline void set_group_id(const void* value, size_t size);
  inline ::std::string* mutable_group_id();
  inline ::std::string* release_group_id();
  inline void set_allocated_group_id(::std::string* group_id);

  // optional .zina.GroupUpdateSetName updateName = 2;
  inline bool has_updatename() const;
  inline void clear_updatename();
  static const int kUpdateNameFieldNumber = 2;
  inline const ::zina::GroupUpdateSetName& updatename() const;
  inline ::zina::GroupUpdateSetName* mutable_updatename();
  inline ::zina::GroupUpdateSetName* release_updatename();
  inline void set_allocated_updatename(::zina::GroupUpdateSetName* updatename);

  // optional .zina.GroupUpdateSetAvatar updateAvatar = 3;
  inline bool has_updateavatar() const;
  inline void clear_updateavatar();
  static const int kUpdateAvatarFieldNumber = 3;
  inline const ::zina::GroupUpdateSetAvatar& updateavatar() const;
  inline ::zina::GroupUpdateSetAvatar* mutable_updateavatar();
  inline ::zina::GroupUpdateSetAvatar* release_updateavatar();
  inline void set_allocated_updateavatar(::zina::GroupUpdateSetAvatar* updateavatar);

  // optional .zina.GroupUpdateSetBurn updateBurn = 4;
  inline bool has_updateburn() const;
  inline void clear_updateburn();
  static const int kUpdateBurnFieldNumber = 4;
  inline const ::zina::GroupUpdateSetBurn& updateburn() const;
  inline ::zina::GroupUpdateSetBurn* mutable_updateburn();
  inline ::zina::GroupUpdateSetBurn* release_updateburn();
  inline void set_allocated_updateburn(::zina::GroupUpdateSetBurn* updateburn);

  // optional .zina.GroupUpdateAddMember updateAddMember = 5;
  inline bool has_updateaddmember() const;
  inline void clear_updateaddmember();
  static const int kUpdateAddMemberFieldNumber = 5;
  inline const ::zina::GroupUpdateAddMember& updateaddmember() const;
  inline ::zina::GroupUpdateAddMember* mutable_updateaddmember();
  inline ::zina::GroupUpdateAddMember* release_updateaddmember();
  inline void set_allocated_updateaddmember(::zina::GroupUpdateAddMember* updateaddmember);

  // optional .zina.GroupUpdateRmMember updateRmMember = 6;
  inline bool has_updatermmember() const;
  inline void clear_updatermmember();
  static const int kUpdateRmMemberFieldNumber = 6;
  inline const ::zina::GroupUpdateRmMember& updatermmember() const;
  inline ::zina::GroupUpdateRmMember* mutable_updatermmember();
  inline ::zina::GroupUpdateRmMember* release_updatermmember();
  inline void set_allocated_updatermmember(::zina::GroupUpdateRmMember* updatermmember);

  // optional .zina.GroupBurnMessage burnMessage = 8;
  inline bool has_burnmessage() const;
  inline void clear_burnmessage();
  static const int kBurnMessageFieldNumber = 8;
  inline const ::zina::GroupBurnMessage& burnmessage() const;
  inline ::zina::GroupBurnMessage* mutable_burnmessage();
  inline ::zina::GroupBurnMessage* release_burnmessage();
  inline void set_allocated_burnmessage(::zina::GroupBurnMessage* burnmessage);

  // repeated .zina.GroupUpdateAck acks = 7;
  inline int acks_size() const;
  inline void clear_acks();
  static const int kAcksFieldNumber = 7;
  inline const ::zina::GroupUpdateAck& acks(int index) const;
  inline ::zina::GroupUpdateAck* mutable_acks(int index);
  inline ::zina::GroupUpdateAck* add_acks();
  inline const ::google::protobuf::RepeatedPtrField< ::zina::GroupUpdateAck >&
      acks() const;
  inline ::google::protobuf::RepeatedPtrField< ::zina::GroupUpdateAck >*
      mutable_acks();

  // @@protoc_insertion_point(class_scope:zina.GroupChangeSet)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_updatename();
  inline void clear_has_updatename();
  inline void set_has_updateavatar();
  inline void clear_has_updateavatar();
  inline void set_has_updateburn();
  inline void clear_has_updateburn();
  inline void set_has_updateaddmember();
  inline void clear_has_updateaddmember();
  inline void set_has_updatermmember();
  inline void clear_has_updatermmember();
  inline void set_has_burnmessage();
  inline void clear_has_burnmessage();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* group_id_;
  ::zina::GroupUpdateSetName* updatename_;
  ::zina::GroupUpdateSetAvatar* updateavatar_;
  ::zina::GroupUpdateSetBurn* updateburn_;
  ::zina::GroupUpdateAddMember* updateaddmember_;
  ::zina::GroupUpdateRmMember* updatermmember_;
  ::zina::GroupBurnMessage* burnmessage_;
  ::google::protobuf::RepeatedPtrField< ::zina::GroupUpdateAck > acks_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GroupProtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GroupProtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_GroupProtocol_2eproto();
  friend void protobuf_ShutdownFile_GroupProtocol_2eproto();

  void InitAsDefaultInstance();
  static GroupChangeSet* default_instance_;
};
// ===================================================================


// ===================================================================

// VClock

// optional bytes device_id = 1;
inline bool VClock::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VClock::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VClock::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VClock::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& VClock::device_id() const {
  // @@protoc_insertion_point(field_get:zina.VClock.device_id)
  return *device_id_;
}
inline void VClock::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.VClock.device_id)
}
inline void VClock::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.VClock.device_id)
}
inline void VClock::set_device_id(const void* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.VClock.device_id)
}
inline ::std::string* VClock::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.VClock.device_id)
  return device_id_;
}
inline ::std::string* VClock::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VClock::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.VClock.device_id)
}

// optional int64 value = 2;
inline bool VClock::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VClock::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VClock::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VClock::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 VClock::value() const {
  // @@protoc_insertion_point(field_get:zina.VClock.value)
  return value_;
}
inline void VClock::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:zina.VClock.value)
}

// -------------------------------------------------------------------

// LocalVClock

// repeated .zina.VClock vclock = 1;
inline int LocalVClock::vclock_size() const {
  return vclock_.size();
}
inline void LocalVClock::clear_vclock() {
  vclock_.Clear();
}
inline const ::zina::VClock& LocalVClock::vclock(int index) const {
  // @@protoc_insertion_point(field_get:zina.LocalVClock.vclock)
  return vclock_.Get(index);
}
inline ::zina::VClock* LocalVClock::mutable_vclock(int index) {
  // @@protoc_insertion_point(field_mutable:zina.LocalVClock.vclock)
  return vclock_.Mutable(index);
}
inline ::zina::VClock* LocalVClock::add_vclock() {
  // @@protoc_insertion_point(field_add:zina.LocalVClock.vclock)
  return vclock_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
LocalVClock::vclock() const {
  // @@protoc_insertion_point(field_list:zina.LocalVClock.vclock)
  return vclock_;
}
inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
LocalVClock::mutable_vclock() {
  // @@protoc_insertion_point(field_mutable_list:zina.LocalVClock.vclock)
  return &vclock_;
}

// optional bytes update_id = 2;
inline bool LocalVClock::has_update_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalVClock::set_has_update_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalVClock::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalVClock::clear_update_id() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_->clear();
  }
  clear_has_update_id();
}
inline const ::std::string& LocalVClock::update_id() const {
  // @@protoc_insertion_point(field_get:zina.LocalVClock.update_id)
  return *update_id_;
}
inline void LocalVClock::set_update_id(const ::std::string& value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.LocalVClock.update_id)
}
inline void LocalVClock::set_update_id(const char* value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.LocalVClock.update_id)
}
inline void LocalVClock::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.LocalVClock.update_id)
}
inline ::std::string* LocalVClock::mutable_update_id() {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.LocalVClock.update_id)
  return update_id_;
}
inline ::std::string* LocalVClock::release_update_id() {
  clear_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = update_id_;
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LocalVClock::set_allocated_update_id(::std::string* update_id) {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  if (update_id) {
    set_has_update_id();
    update_id_ = update_id;
  } else {
    clear_has_update_id();
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.LocalVClock.update_id)
}

// -------------------------------------------------------------------

// Member

// optional string user_id = 1;
inline bool Member::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Member::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Member::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Member::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& Member::user_id() const {
  // @@protoc_insertion_point(field_get:zina.Member.user_id)
  return *user_id_;
}
inline void Member::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.Member.user_id)
}
inline void Member::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.Member.user_id)
}
inline void Member::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.Member.user_id)
}
inline ::std::string* Member::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.Member.user_id)
  return user_id_;
}
inline ::std::string* Member::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Member::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.Member.user_id)
}

// -------------------------------------------------------------------

// GroupUpdateSetName

// optional bytes update_id = 1;
inline bool GroupUpdateSetName::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateSetName::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateSetName::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateSetName::clear_update_id() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_->clear();
  }
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateSetName::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetName.update_id)
  return *update_id_;
}
inline void GroupUpdateSetName::set_update_id(const ::std::string& value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetName.update_id)
}
inline void GroupUpdateSetName::set_update_id(const char* value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetName.update_id)
}
inline void GroupUpdateSetName::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetName.update_id)
}
inline ::std::string* GroupUpdateSetName::mutable_update_id() {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetName.update_id)
  return update_id_;
}
inline ::std::string* GroupUpdateSetName::release_update_id() {
  clear_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = update_id_;
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupUpdateSetName::set_allocated_update_id(::std::string* update_id) {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  if (update_id) {
    set_has_update_id();
    update_id_ = update_id;
  } else {
    clear_has_update_id();
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetName.update_id)
}

// repeated .zina.VClock vclock = 2;
inline int GroupUpdateSetName::vclock_size() const {
  return vclock_.size();
}
inline void GroupUpdateSetName::clear_vclock() {
  vclock_.Clear();
}
inline const ::zina::VClock& GroupUpdateSetName::vclock(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetName.vclock)
  return vclock_.Get(index);
}
inline ::zina::VClock* GroupUpdateSetName::mutable_vclock(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetName.vclock)
  return vclock_.Mutable(index);
}
inline ::zina::VClock* GroupUpdateSetName::add_vclock() {
  // @@protoc_insertion_point(field_add:zina.GroupUpdateSetName.vclock)
  return vclock_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
GroupUpdateSetName::vclock() const {
  // @@protoc_insertion_point(field_list:zina.GroupUpdateSetName.vclock)
  return vclock_;
}
inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
GroupUpdateSetName::mutable_vclock() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupUpdateSetName.vclock)
  return &vclock_;
}

// optional string name = 3;
inline bool GroupUpdateSetName::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUpdateSetName::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUpdateSetName::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUpdateSetName::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GroupUpdateSetName::name() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetName.name)
  return *name_;
}
inline void GroupUpdateSetName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetName.name)
}
inline void GroupUpdateSetName::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetName.name)
}
inline void GroupUpdateSetName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetName.name)
}
inline ::std::string* GroupUpdateSetName::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetName.name)
  return name_;
}
inline ::std::string* GroupUpdateSetName::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupUpdateSetName::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetName.name)
}

// -------------------------------------------------------------------

// GroupUpdateSetAvatar

// optional bytes update_id = 1;
inline bool GroupUpdateSetAvatar::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateSetAvatar::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateSetAvatar::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateSetAvatar::clear_update_id() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_->clear();
  }
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateSetAvatar::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetAvatar.update_id)
  return *update_id_;
}
inline void GroupUpdateSetAvatar::set_update_id(const ::std::string& value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetAvatar.update_id)
}
inline void GroupUpdateSetAvatar::set_update_id(const char* value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetAvatar.update_id)
}
inline void GroupUpdateSetAvatar::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetAvatar.update_id)
}
inline ::std::string* GroupUpdateSetAvatar::mutable_update_id() {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetAvatar.update_id)
  return update_id_;
}
inline ::std::string* GroupUpdateSetAvatar::release_update_id() {
  clear_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = update_id_;
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupUpdateSetAvatar::set_allocated_update_id(::std::string* update_id) {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  if (update_id) {
    set_has_update_id();
    update_id_ = update_id;
  } else {
    clear_has_update_id();
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetAvatar.update_id)
}

// repeated .zina.VClock vclock = 2;
inline int GroupUpdateSetAvatar::vclock_size() const {
  return vclock_.size();
}
inline void GroupUpdateSetAvatar::clear_vclock() {
  vclock_.Clear();
}
inline const ::zina::VClock& GroupUpdateSetAvatar::vclock(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetAvatar.vclock)
  return vclock_.Get(index);
}
inline ::zina::VClock* GroupUpdateSetAvatar::mutable_vclock(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetAvatar.vclock)
  return vclock_.Mutable(index);
}
inline ::zina::VClock* GroupUpdateSetAvatar::add_vclock() {
  // @@protoc_insertion_point(field_add:zina.GroupUpdateSetAvatar.vclock)
  return vclock_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
GroupUpdateSetAvatar::vclock() const {
  // @@protoc_insertion_point(field_list:zina.GroupUpdateSetAvatar.vclock)
  return vclock_;
}
inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
GroupUpdateSetAvatar::mutable_vclock() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupUpdateSetAvatar.vclock)
  return &vclock_;
}

// optional string avatar = 3;
inline bool GroupUpdateSetAvatar::has_avatar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUpdateSetAvatar::set_has_avatar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUpdateSetAvatar::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUpdateSetAvatar::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& GroupUpdateSetAvatar::avatar() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetAvatar.avatar)
  return *avatar_;
}
inline void GroupUpdateSetAvatar::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetAvatar.avatar)
}
inline void GroupUpdateSetAvatar::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetAvatar.avatar)
}
inline void GroupUpdateSetAvatar::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetAvatar.avatar)
}
inline ::std::string* GroupUpdateSetAvatar::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetAvatar.avatar)
  return avatar_;
}
inline ::std::string* GroupUpdateSetAvatar::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupUpdateSetAvatar::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetAvatar.avatar)
}

// -------------------------------------------------------------------

// GroupUpdateSetBurn

// optional bytes update_id = 1;
inline bool GroupUpdateSetBurn::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateSetBurn::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateSetBurn::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateSetBurn::clear_update_id() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_->clear();
  }
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateSetBurn::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetBurn.update_id)
  return *update_id_;
}
inline void GroupUpdateSetBurn::set_update_id(const ::std::string& value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetBurn.update_id)
}
inline void GroupUpdateSetBurn::set_update_id(const char* value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetBurn.update_id)
}
inline void GroupUpdateSetBurn::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetBurn.update_id)
}
inline ::std::string* GroupUpdateSetBurn::mutable_update_id() {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetBurn.update_id)
  return update_id_;
}
inline ::std::string* GroupUpdateSetBurn::release_update_id() {
  clear_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = update_id_;
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupUpdateSetBurn::set_allocated_update_id(::std::string* update_id) {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  if (update_id) {
    set_has_update_id();
    update_id_ = update_id;
  } else {
    clear_has_update_id();
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetBurn.update_id)
}

// repeated .zina.VClock vclock = 2;
inline int GroupUpdateSetBurn::vclock_size() const {
  return vclock_.size();
}
inline void GroupUpdateSetBurn::clear_vclock() {
  vclock_.Clear();
}
inline const ::zina::VClock& GroupUpdateSetBurn::vclock(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetBurn.vclock)
  return vclock_.Get(index);
}
inline ::zina::VClock* GroupUpdateSetBurn::mutable_vclock(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetBurn.vclock)
  return vclock_.Mutable(index);
}
inline ::zina::VClock* GroupUpdateSetBurn::add_vclock() {
  // @@protoc_insertion_point(field_add:zina.GroupUpdateSetBurn.vclock)
  return vclock_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
GroupUpdateSetBurn::vclock() const {
  // @@protoc_insertion_point(field_list:zina.GroupUpdateSetBurn.vclock)
  return vclock_;
}
inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
GroupUpdateSetBurn::mutable_vclock() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupUpdateSetBurn.vclock)
  return &vclock_;
}

// optional .zina.GroupUpdateSetBurn.BurnMode burn_mode = 3;
inline bool GroupUpdateSetBurn::has_burn_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUpdateSetBurn::set_has_burn_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUpdateSetBurn::clear_has_burn_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUpdateSetBurn::clear_burn_mode() {
  burn_mode_ = 0;
  clear_has_burn_mode();
}
inline ::zina::GroupUpdateSetBurn_BurnMode GroupUpdateSetBurn::burn_mode() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetBurn.burn_mode)
  return static_cast< ::zina::GroupUpdateSetBurn_BurnMode >(burn_mode_);
}
inline void GroupUpdateSetBurn::set_burn_mode(::zina::GroupUpdateSetBurn_BurnMode value) {
  assert(::zina::GroupUpdateSetBurn_BurnMode_IsValid(value));
  set_has_burn_mode();
  burn_mode_ = value;
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetBurn.burn_mode)
}

// optional uint64 burn_ttl_sec = 4;
inline bool GroupUpdateSetBurn::has_burn_ttl_sec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupUpdateSetBurn::set_has_burn_ttl_sec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupUpdateSetBurn::clear_has_burn_ttl_sec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupUpdateSetBurn::clear_burn_ttl_sec() {
  burn_ttl_sec_ = GOOGLE_ULONGLONG(0);
  clear_has_burn_ttl_sec();
}
inline ::google::protobuf::uint64 GroupUpdateSetBurn::burn_ttl_sec() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetBurn.burn_ttl_sec)
  return burn_ttl_sec_;
}
inline void GroupUpdateSetBurn::set_burn_ttl_sec(::google::protobuf::uint64 value) {
  set_has_burn_ttl_sec();
  burn_ttl_sec_ = value;
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetBurn.burn_ttl_sec)
}

// -------------------------------------------------------------------

// GroupUpdateAddMember

// optional bytes update_id = 1;
inline bool GroupUpdateAddMember::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateAddMember::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateAddMember::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateAddMember::clear_update_id() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_->clear();
  }
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateAddMember::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAddMember.update_id)
  return *update_id_;
}
inline void GroupUpdateAddMember::set_update_id(const ::std::string& value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateAddMember.update_id)
}
inline void GroupUpdateAddMember::set_update_id(const char* value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateAddMember.update_id)
}
inline void GroupUpdateAddMember::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateAddMember.update_id)
}
inline ::std::string* GroupUpdateAddMember::mutable_update_id() {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateAddMember.update_id)
  return update_id_;
}
inline ::std::string* GroupUpdateAddMember::release_update_id() {
  clear_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = update_id_;
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupUpdateAddMember::set_allocated_update_id(::std::string* update_id) {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  if (update_id) {
    set_has_update_id();
    update_id_ = update_id;
  } else {
    clear_has_update_id();
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateAddMember.update_id)
}

// repeated .zina.Member addMember = 2;
inline int GroupUpdateAddMember::addmember_size() const {
  return addmember_.size();
}
inline void GroupUpdateAddMember::clear_addmember() {
  addmember_.Clear();
}
inline const ::zina::Member& GroupUpdateAddMember::addmember(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAddMember.addMember)
  return addmember_.Get(index);
}
inline ::zina::Member* GroupUpdateAddMember::mutable_addmember(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateAddMember.addMember)
  return addmember_.Mutable(index);
}
inline ::zina::Member* GroupUpdateAddMember::add_addmember() {
  // @@protoc_insertion_point(field_add:zina.GroupUpdateAddMember.addMember)
  return addmember_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::Member >&
GroupUpdateAddMember::addmember() const {
  // @@protoc_insertion_point(field_list:zina.GroupUpdateAddMember.addMember)
  return addmember_;
}
inline ::google::protobuf::RepeatedPtrField< ::zina::Member >*
GroupUpdateAddMember::mutable_addmember() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupUpdateAddMember.addMember)
  return &addmember_;
}

// -------------------------------------------------------------------

// GroupUpdateRmMember

// optional bytes update_id = 1;
inline bool GroupUpdateRmMember::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateRmMember::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateRmMember::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateRmMember::clear_update_id() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_->clear();
  }
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateRmMember::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateRmMember.update_id)
  return *update_id_;
}
inline void GroupUpdateRmMember::set_update_id(const ::std::string& value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateRmMember.update_id)
}
inline void GroupUpdateRmMember::set_update_id(const char* value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateRmMember.update_id)
}
inline void GroupUpdateRmMember::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateRmMember.update_id)
}
inline ::std::string* GroupUpdateRmMember::mutable_update_id() {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateRmMember.update_id)
  return update_id_;
}
inline ::std::string* GroupUpdateRmMember::release_update_id() {
  clear_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = update_id_;
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupUpdateRmMember::set_allocated_update_id(::std::string* update_id) {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  if (update_id) {
    set_has_update_id();
    update_id_ = update_id;
  } else {
    clear_has_update_id();
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateRmMember.update_id)
}

// repeated .zina.Member rmMember = 2;
inline int GroupUpdateRmMember::rmmember_size() const {
  return rmmember_.size();
}
inline void GroupUpdateRmMember::clear_rmmember() {
  rmmember_.Clear();
}
inline const ::zina::Member& GroupUpdateRmMember::rmmember(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateRmMember.rmMember)
  return rmmember_.Get(index);
}
inline ::zina::Member* GroupUpdateRmMember::mutable_rmmember(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateRmMember.rmMember)
  return rmmember_.Mutable(index);
}
inline ::zina::Member* GroupUpdateRmMember::add_rmmember() {
  // @@protoc_insertion_point(field_add:zina.GroupUpdateRmMember.rmMember)
  return rmmember_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::Member >&
GroupUpdateRmMember::rmmember() const {
  // @@protoc_insertion_point(field_list:zina.GroupUpdateRmMember.rmMember)
  return rmmember_;
}
inline ::google::protobuf::RepeatedPtrField< ::zina::Member >*
GroupUpdateRmMember::mutable_rmmember() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupUpdateRmMember.rmMember)
  return &rmmember_;
}

// -------------------------------------------------------------------

// GroupBurnMessage

// optional bytes update_id = 1;
inline bool GroupBurnMessage::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupBurnMessage::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupBurnMessage::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupBurnMessage::clear_update_id() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_->clear();
  }
  clear_has_update_id();
}
inline const ::std::string& GroupBurnMessage::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupBurnMessage.update_id)
  return *update_id_;
}
inline void GroupBurnMessage::set_update_id(const ::std::string& value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.GroupBurnMessage.update_id)
}
inline void GroupBurnMessage::set_update_id(const char* value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupBurnMessage.update_id)
}
inline void GroupBurnMessage::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupBurnMessage.update_id)
}
inline ::std::string* GroupBurnMessage::mutable_update_id() {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupBurnMessage.update_id)
  return update_id_;
}
inline ::std::string* GroupBurnMessage::release_update_id() {
  clear_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = update_id_;
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupBurnMessage::set_allocated_update_id(::std::string* update_id) {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  if (update_id) {
    set_has_update_id();
    update_id_ = update_id;
  } else {
    clear_has_update_id();
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupBurnMessage.update_id)
}

// repeated string msgId = 2;
inline int GroupBurnMessage::msgid_size() const {
  return msgid_.size();
}
inline void GroupBurnMessage::clear_msgid() {
  msgid_.Clear();
}
inline const ::std::string& GroupBurnMessage::msgid(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupBurnMessage.msgId)
  return msgid_.Get(index);
}
inline ::std::string* GroupBurnMessage::mutable_msgid(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupBurnMessage.msgId)
  return msgid_.Mutable(index);
}
inline void GroupBurnMessage::set_msgid(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zina.GroupBurnMessage.msgId)
  msgid_.Mutable(index)->assign(value);
}
inline void GroupBurnMessage::set_msgid(int index, const char* value) {
  msgid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupBurnMessage.msgId)
}
inline void GroupBurnMessage::set_msgid(int index, const char* value, size_t size) {
  msgid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupBurnMessage.msgId)
}
inline ::std::string* GroupBurnMessage::add_msgid() {
  return msgid_.Add();
}
inline void GroupBurnMessage::add_msgid(const ::std::string& value) {
  msgid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zina.GroupBurnMessage.msgId)
}
inline void GroupBurnMessage::add_msgid(const char* value) {
  msgid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zina.GroupBurnMessage.msgId)
}
inline void GroupBurnMessage::add_msgid(const char* value, size_t size) {
  msgid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zina.GroupBurnMessage.msgId)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupBurnMessage::msgid() const {
  // @@protoc_insertion_point(field_list:zina.GroupBurnMessage.msgId)
  return msgid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupBurnMessage::mutable_msgid() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupBurnMessage.msgId)
  return &msgid_;
}

// optional .zina.Member member = 3;
inline bool GroupBurnMessage::has_member() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupBurnMessage::set_has_member() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupBurnMessage::clear_has_member() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupBurnMessage::clear_member() {
  if (member_ != NULL) member_->::zina::Member::Clear();
  clear_has_member();
}
inline const ::zina::Member& GroupBurnMessage::member() const {
  // @@protoc_insertion_point(field_get:zina.GroupBurnMessage.member)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return member_ != NULL ? *member_ : *default_instance().member_;
#else
  return member_ != NULL ? *member_ : *default_instance_->member_;
#endif
}
inline ::zina::Member* GroupBurnMessage::mutable_member() {
  set_has_member();
  if (member_ == NULL) member_ = new ::zina::Member;
  // @@protoc_insertion_point(field_mutable:zina.GroupBurnMessage.member)
  return member_;
}
inline ::zina::Member* GroupBurnMessage::release_member() {
  clear_has_member();
  ::zina::Member* temp = member_;
  member_ = NULL;
  return temp;
}
inline void GroupBurnMessage::set_allocated_member(::zina::Member* member) {
  delete member_;
  member_ = member;
  if (member) {
    set_has_member();
  } else {
    clear_has_member();
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupBurnMessage.member)
}

// -------------------------------------------------------------------

// GroupUpdateAck

// optional .zina.GroupUpdateType type = 1;
inline bool GroupUpdateAck::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateAck::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateAck::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateAck::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::zina::GroupUpdateType GroupUpdateAck::type() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAck.type)
  return static_cast< ::zina::GroupUpdateType >(type_);
}
inline void GroupUpdateAck::set_type(::zina::GroupUpdateType value) {
  assert(::zina::GroupUpdateType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:zina.GroupUpdateAck.type)
}

// optional bytes update_id = 2;
inline bool GroupUpdateAck::has_update_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUpdateAck::set_has_update_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUpdateAck::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUpdateAck::clear_update_id() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_->clear();
  }
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateAck::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAck.update_id)
  return *update_id_;
}
inline void GroupUpdateAck::set_update_id(const ::std::string& value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateAck.update_id)
}
inline void GroupUpdateAck::set_update_id(const char* value) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateAck.update_id)
}
inline void GroupUpdateAck::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  update_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateAck.update_id)
}
inline ::std::string* GroupUpdateAck::mutable_update_id() {
  set_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    update_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateAck.update_id)
  return update_id_;
}
inline ::std::string* GroupUpdateAck::release_update_id() {
  clear_has_update_id();
  if (update_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = update_id_;
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupUpdateAck::set_allocated_update_id(::std::string* update_id) {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  if (update_id) {
    set_has_update_id();
    update_id_ = update_id;
  } else {
    clear_has_update_id();
    update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateAck.update_id)
}

// optional .zina.GroupUpdateResult result = 3;
inline bool GroupUpdateAck::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUpdateAck::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUpdateAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUpdateAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::zina::GroupUpdateResult GroupUpdateAck::result() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAck.result)
  return static_cast< ::zina::GroupUpdateResult >(result_);
}
inline void GroupUpdateAck::set_result(::zina::GroupUpdateResult value) {
  assert(::zina::GroupUpdateResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:zina.GroupUpdateAck.result)
}

// -------------------------------------------------------------------

// GroupChangeSet

// optional bytes group_id = 1;
inline bool GroupChangeSet::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupChangeSet::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupChangeSet::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupChangeSet::clear_group_id() {
  if (group_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_id_->clear();
  }
  clear_has_group_id();
}
inline const ::std::string& GroupChangeSet::group_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.group_id)
  return *group_id_;
}
inline void GroupChangeSet::set_group_id(const ::std::string& value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
  // @@protoc_insertion_point(field_set:zina.GroupChangeSet.group_id)
}
inline void GroupChangeSet::set_group_id(const char* value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupChangeSet.group_id)
}
inline void GroupChangeSet::set_group_id(const void* value, size_t size) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupChangeSet.group_id)
}
inline ::std::string* GroupChangeSet::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.group_id)
  return group_id_;
}
inline ::std::string* GroupChangeSet::release_group_id() {
  clear_has_group_id();
  if (group_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_id_;
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupChangeSet::set_allocated_group_id(::std::string* group_id) {
  if (group_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_id_;
  }
  if (group_id) {
    set_has_group_id();
    group_id_ = group_id;
  } else {
    clear_has_group_id();
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.group_id)
}

// optional .zina.GroupUpdateSetName updateName = 2;
inline bool GroupChangeSet::has_updatename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupChangeSet::set_has_updatename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupChangeSet::clear_has_updatename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupChangeSet::clear_updatename() {
  if (updatename_ != NULL) updatename_->::zina::GroupUpdateSetName::Clear();
  clear_has_updatename();
}
inline const ::zina::GroupUpdateSetName& GroupChangeSet::updatename() const {
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.updateName)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return updatename_ != NULL ? *updatename_ : *default_instance().updatename_;
#else
  return updatename_ != NULL ? *updatename_ : *default_instance_->updatename_;
#endif
}
inline ::zina::GroupUpdateSetName* GroupChangeSet::mutable_updatename() {
  set_has_updatename();
  if (updatename_ == NULL) updatename_ = new ::zina::GroupUpdateSetName;
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.updateName)
  return updatename_;
}
inline ::zina::GroupUpdateSetName* GroupChangeSet::release_updatename() {
  clear_has_updatename();
  ::zina::GroupUpdateSetName* temp = updatename_;
  updatename_ = NULL;
  return temp;
}
inline void GroupChangeSet::set_allocated_updatename(::zina::GroupUpdateSetName* updatename) {
  delete updatename_;
  updatename_ = updatename;
  if (updatename) {
    set_has_updatename();
  } else {
    clear_has_updatename();
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.updateName)
}

// optional .zina.GroupUpdateSetAvatar updateAvatar = 3;
inline bool GroupChangeSet::has_updateavatar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupChangeSet::set_has_updateavatar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupChangeSet::clear_has_updateavatar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupChangeSet::clear_updateavatar() {
  if (updateavatar_ != NULL) updateavatar_->::zina::GroupUpdateSetAvatar::Clear();
  clear_has_updateavatar();
}
inline const ::zina::GroupUpdateSetAvatar& GroupChangeSet::updateavatar() const {
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.updateAvatar)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return updateavatar_ != NULL ? *updateavatar_ : *default_instance().updateavatar_;
#else
  return updateavatar_ != NULL ? *updateavatar_ : *default_instance_->updateavatar_;
#endif
}
inline ::zina::GroupUpdateSetAvatar* GroupChangeSet::mutable_updateavatar() {
  set_has_updateavatar();
  if (updateavatar_ == NULL) updateavatar_ = new ::zina::GroupUpdateSetAvatar;
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.updateAvatar)
  return updateavatar_;
}
inline ::zina::GroupUpdateSetAvatar* GroupChangeSet::release_updateavatar() {
  clear_has_updateavatar();
  ::zina::GroupUpdateSetAvatar* temp = updateavatar_;
  updateavatar_ = NULL;
  return temp;
}
inline void GroupChangeSet::set_allocated_updateavatar(::zina::GroupUpdateSetAvatar* updateavatar) {
  delete updateavatar_;
  updateavatar_ = updateavatar;
  if (updateavatar) {
    set_has_updateavatar();
  } else {
    clear_has_updateavatar();
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.updateAvatar)
}

// optional .zina.GroupUpdateSetBurn updateBurn = 4;
inline bool GroupChangeSet::has_updateburn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupChangeSet::set_has_updateburn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupChangeSet::clear_has_updateburn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupChangeSet::clear_updateburn() {
  if (updateburn_ != NULL) updateburn_->::zina::GroupUpdateSetBurn::Clear();
  clear_has_updateburn();
}
inline const ::zina::GroupUpdateSetBurn& GroupChangeSet::updateburn() const {
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.updateBurn)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return updateburn_ != NULL ? *updateburn_ : *default_instance().updateburn_;
#else
  return updateburn_ != NULL ? *updateburn_ : *default_instance_->updateburn_;
#endif
}
inline ::zina::GroupUpdateSetBurn* GroupChangeSet::mutable_updateburn() {
  set_has_updateburn();
  if (updateburn_ == NULL) updateburn_ = new ::zina::GroupUpdateSetBurn;
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.updateBurn)
  return updateburn_;
}
inline ::zina::GroupUpdateSetBurn* GroupChangeSet::release_updateburn() {
  clear_has_updateburn();
  ::zina::GroupUpdateSetBurn* temp = updateburn_;
  updateburn_ = NULL;
  return temp;
}
inline void GroupChangeSet::set_allocated_updateburn(::zina::GroupUpdateSetBurn* updateburn) {
  delete updateburn_;
  updateburn_ = updateburn;
  if (updateburn) {
    set_has_updateburn();
  } else {
    clear_has_updateburn();
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.updateBurn)
}

// optional .zina.GroupUpdateAddMember updateAddMember = 5;
inline bool GroupChangeSet::has_updateaddmember() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupChangeSet::set_has_updateaddmember() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupChangeSet::clear_has_updateaddmember() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupChangeSet::clear_updateaddmember() {
  if (updateaddmember_ != NULL) updateaddmember_->::zina::GroupUpdateAddMember::Clear();
  clear_has_updateaddmember();
}
inline const ::zina::GroupUpdateAddMember& GroupChangeSet::updateaddmember() const {
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.updateAddMember)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return updateaddmember_ != NULL ? *updateaddmember_ : *default_instance().updateaddmember_;
#else
  return updateaddmember_ != NULL ? *updateaddmember_ : *default_instance_->updateaddmember_;
#endif
}
inline ::zina::GroupUpdateAddMember* GroupChangeSet::mutable_updateaddmember() {
  set_has_updateaddmember();
  if (updateaddmember_ == NULL) updateaddmember_ = new ::zina::GroupUpdateAddMember;
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.updateAddMember)
  return updateaddmember_;
}
inline ::zina::GroupUpdateAddMember* GroupChangeSet::release_updateaddmember() {
  clear_has_updateaddmember();
  ::zina::GroupUpdateAddMember* temp = updateaddmember_;
  updateaddmember_ = NULL;
  return temp;
}
inline void GroupChangeSet::set_allocated_updateaddmember(::zina::GroupUpdateAddMember* updateaddmember) {
  delete updateaddmember_;
  updateaddmember_ = updateaddmember;
  if (updateaddmember) {
    set_has_updateaddmember();
  } else {
    clear_has_updateaddmember();
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.updateAddMember)
}

// optional .zina.GroupUpdateRmMember updateRmMember = 6;
inline bool GroupChangeSet::has_updatermmember() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupChangeSet::set_has_updatermmember() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupChangeSet::clear_has_updatermmember() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupChangeSet::clear_updatermmember() {
  if (updatermmember_ != NULL) updatermmember_->::zina::GroupUpdateRmMember::Clear();
  clear_has_updatermmember();
}
inline const ::zina::GroupUpdateRmMember& GroupChangeSet::updatermmember() const {
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.updateRmMember)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return updatermmember_ != NULL ? *updatermmember_ : *default_instance().updatermmember_;
#else
  return updatermmember_ != NULL ? *updatermmember_ : *default_instance_->updatermmember_;
#endif
}
inline ::zina::GroupUpdateRmMember* GroupChangeSet::mutable_updatermmember() {
  set_has_updatermmember();
  if (updatermmember_ == NULL) updatermmember_ = new ::zina::GroupUpdateRmMember;
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.updateRmMember)
  return updatermmember_;
}
inline ::zina::GroupUpdateRmMember* GroupChangeSet::release_updatermmember() {
  clear_has_updatermmember();
  ::zina::GroupUpdateRmMember* temp = updatermmember_;
  updatermmember_ = NULL;
  return temp;
}
inline void GroupChangeSet::set_allocated_updatermmember(::zina::GroupUpdateRmMember* updatermmember) {
  delete updatermmember_;
  updatermmember_ = updatermmember;
  if (updatermmember) {
    set_has_updatermmember();
  } else {
    clear_has_updatermmember();
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.updateRmMember)
}

// optional .zina.GroupBurnMessage burnMessage = 8;
inline bool GroupChangeSet::has_burnmessage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupChangeSet::set_has_burnmessage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupChangeSet::clear_has_burnmessage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupChangeSet::clear_burnmessage() {
  if (burnmessage_ != NULL) burnmessage_->::zina::GroupBurnMessage::Clear();
  clear_has_burnmessage();
}
inline const ::zina::GroupBurnMessage& GroupChangeSet::burnmessage() const {
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.burnMessage)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return burnmessage_ != NULL ? *burnmessage_ : *default_instance().burnmessage_;
#else
  return burnmessage_ != NULL ? *burnmessage_ : *default_instance_->burnmessage_;
#endif
}
inline ::zina::GroupBurnMessage* GroupChangeSet::mutable_burnmessage() {
  set_has_burnmessage();
  if (burnmessage_ == NULL) burnmessage_ = new ::zina::GroupBurnMessage;
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.burnMessage)
  return burnmessage_;
}
inline ::zina::GroupBurnMessage* GroupChangeSet::release_burnmessage() {
  clear_has_burnmessage();
  ::zina::GroupBurnMessage* temp = burnmessage_;
  burnmessage_ = NULL;
  return temp;
}
inline void GroupChangeSet::set_allocated_burnmessage(::zina::GroupBurnMessage* burnmessage) {
  delete burnmessage_;
  burnmessage_ = burnmessage;
  if (burnmessage) {
    set_has_burnmessage();
  } else {
    clear_has_burnmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.burnMessage)
}

// repeated .zina.GroupUpdateAck acks = 7;
inline int GroupChangeSet::acks_size() const {
  return acks_.size();
}
inline void GroupChangeSet::clear_acks() {
  acks_.Clear();
}
inline const ::zina::GroupUpdateAck& GroupChangeSet::acks(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.acks)
  return acks_.Get(index);
}
inline ::zina::GroupUpdateAck* GroupChangeSet::mutable_acks(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.acks)
  return acks_.Mutable(index);
}
inline ::zina::GroupUpdateAck* GroupChangeSet::add_acks() {
  // @@protoc_insertion_point(field_add:zina.GroupChangeSet.acks)
  return acks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::GroupUpdateAck >&
GroupChangeSet::acks() const {
  // @@protoc_insertion_point(field_list:zina.GroupChangeSet.acks)
  return acks_;
}
inline ::google::protobuf::RepeatedPtrField< ::zina::GroupUpdateAck >*
GroupChangeSet::mutable_acks() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupChangeSet.acks)
  return &acks_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace zina

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GroupProtocol_2eproto__INCLUDED
