// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GroupProtocol.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "GroupProtocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace zina {

void protobuf_ShutdownFile_GroupProtocol_2eproto() {
  delete VClock::default_instance_;
  delete LocalVClock::default_instance_;
  delete Member::default_instance_;
  delete GroupUpdateSetName::default_instance_;
  delete GroupUpdateSetAvatar::default_instance_;
  delete GroupUpdateSetBurn::default_instance_;
  delete GroupUpdateAddMember::default_instance_;
  delete GroupUpdateRmMember::default_instance_;
  delete GroupBurnMessage::default_instance_;
  delete GroupUpdateAck::default_instance_;
  delete GroupChangeSet::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_GroupProtocol_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_GroupProtocol_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  VClock::default_instance_ = new VClock();
  LocalVClock::default_instance_ = new LocalVClock();
  Member::default_instance_ = new Member();
  GroupUpdateSetName::default_instance_ = new GroupUpdateSetName();
  GroupUpdateSetAvatar::default_instance_ = new GroupUpdateSetAvatar();
  GroupUpdateSetBurn::default_instance_ = new GroupUpdateSetBurn();
  GroupUpdateAddMember::default_instance_ = new GroupUpdateAddMember();
  GroupUpdateRmMember::default_instance_ = new GroupUpdateRmMember();
  GroupBurnMessage::default_instance_ = new GroupBurnMessage();
  GroupUpdateAck::default_instance_ = new GroupUpdateAck();
  GroupChangeSet::default_instance_ = new GroupChangeSet();
  VClock::default_instance_->InitAsDefaultInstance();
  LocalVClock::default_instance_->InitAsDefaultInstance();
  Member::default_instance_->InitAsDefaultInstance();
  GroupUpdateSetName::default_instance_->InitAsDefaultInstance();
  GroupUpdateSetAvatar::default_instance_->InitAsDefaultInstance();
  GroupUpdateSetBurn::default_instance_->InitAsDefaultInstance();
  GroupUpdateAddMember::default_instance_->InitAsDefaultInstance();
  GroupUpdateRmMember::default_instance_->InitAsDefaultInstance();
  GroupBurnMessage::default_instance_->InitAsDefaultInstance();
  GroupUpdateAck::default_instance_->InitAsDefaultInstance();
  GroupChangeSet::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_GroupProtocol_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_GroupProtocol_2eproto_once_);
void protobuf_AddDesc_GroupProtocol_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_GroupProtocol_2eproto_once_,
                 &protobuf_AddDesc_GroupProtocol_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_GroupProtocol_2eproto {
  StaticDescriptorInitializer_GroupProtocol_2eproto() {
    protobuf_AddDesc_GroupProtocol_2eproto();
  }
} static_descriptor_initializer_GroupProtocol_2eproto_;
#endif
bool GroupUpdateType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

bool GroupUpdateResult_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int VClock::kDeviceIdFieldNumber;
const int VClock::kValueFieldNumber;
#endif  // !_MSC_VER

VClock::VClock()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.VClock)
}

void VClock::InitAsDefaultInstance() {
}

VClock::VClock(const VClock& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.VClock)
}

void VClock::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VClock::~VClock() {
  // @@protoc_insertion_point(destructor:zina.VClock)
  SharedDtor();
}

void VClock::SharedDtor() {
  if (device_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VClock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VClock& VClock::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

VClock* VClock::default_instance_ = NULL;

VClock* VClock::New() const {
  return new VClock;
}

void VClock::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_device_id()) {
      if (device_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        device_id_->clear();
      }
    }
    value_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool VClock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.VClock)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes device_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_device_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // optional int64 value = 2;
      case 2: {
        if (tag == 16) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.VClock)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.VClock)
  return false;
#undef DO_
}

void VClock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.VClock)
  // optional bytes device_id = 1;
  if (has_device_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->device_id(), output);
  }

  // optional int64 value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.VClock)
}

int VClock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes device_id = 1;
    if (has_device_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->device_id());
    }

    // optional int64 value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->value());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VClock::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VClock*>(&from));
}

void VClock::MergeFrom(const VClock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_device_id()) {
      set_device_id(from.device_id());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void VClock::CopyFrom(const VClock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VClock::IsInitialized() const {

  return true;
}

void VClock::Swap(VClock* other) {
  if (other != this) {
    std::swap(device_id_, other->device_id_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VClock::GetTypeName() const {
  return "zina.VClock";
}


// ===================================================================

#ifndef _MSC_VER
const int LocalVClock::kVclockFieldNumber;
const int LocalVClock::kUpdateIdFieldNumber;
#endif  // !_MSC_VER

LocalVClock::LocalVClock()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.LocalVClock)
}

void LocalVClock::InitAsDefaultInstance() {
}

LocalVClock::LocalVClock(const LocalVClock& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.LocalVClock)
}

void LocalVClock::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LocalVClock::~LocalVClock() {
  // @@protoc_insertion_point(destructor:zina.LocalVClock)
  SharedDtor();
}

void LocalVClock::SharedDtor() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LocalVClock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LocalVClock& LocalVClock::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

LocalVClock* LocalVClock::default_instance_ = NULL;

LocalVClock* LocalVClock::New() const {
  return new LocalVClock;
}

void LocalVClock::Clear() {
  if (has_update_id()) {
    if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      update_id_->clear();
    }
  }
  vclock_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LocalVClock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.LocalVClock)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .zina.VClock vclock = 1;
      case 1: {
        if (tag == 10) {
         parse_vclock:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_vclock()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_vclock;
        if (input->ExpectTag(18)) goto parse_update_id;
        break;
      }

      // optional bytes update_id = 2;
      case 2: {
        if (tag == 18) {
         parse_update_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_update_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.LocalVClock)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.LocalVClock)
  return false;
#undef DO_
}

void LocalVClock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.LocalVClock)
  // repeated .zina.VClock vclock = 1;
  for (int i = 0; i < this->vclock_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->vclock(i), output);
  }

  // optional bytes update_id = 2;
  if (has_update_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->update_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.LocalVClock)
}

int LocalVClock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bytes update_id = 2;
    if (has_update_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->update_id());
    }

  }
  // repeated .zina.VClock vclock = 1;
  total_size += 1 * this->vclock_size();
  for (int i = 0; i < this->vclock_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->vclock(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LocalVClock::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LocalVClock*>(&from));
}

void LocalVClock::MergeFrom(const LocalVClock& from) {
  GOOGLE_CHECK_NE(&from, this);
  vclock_.MergeFrom(from.vclock_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_update_id()) {
      set_update_id(from.update_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LocalVClock::CopyFrom(const LocalVClock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalVClock::IsInitialized() const {

  return true;
}

void LocalVClock::Swap(LocalVClock* other) {
  if (other != this) {
    vclock_.Swap(&other->vclock_);
    std::swap(update_id_, other->update_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LocalVClock::GetTypeName() const {
  return "zina.LocalVClock";
}


// ===================================================================

#ifndef _MSC_VER
const int Member::kUserIdFieldNumber;
#endif  // !_MSC_VER

Member::Member()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.Member)
}

void Member::InitAsDefaultInstance() {
}

Member::Member(const Member& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.Member)
}

void Member::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Member::~Member() {
  // @@protoc_insertion_point(destructor:zina.Member)
  SharedDtor();
}

void Member::SharedDtor() {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Member::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Member& Member::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

Member* Member::default_instance_ = NULL;

Member* Member::New() const {
  return new Member;
}

void Member::Clear() {
  if (has_user_id()) {
    if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      user_id_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Member::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.Member)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string user_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.Member)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.Member)
  return false;
#undef DO_
}

void Member::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.Member)
  // optional string user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.Member)
}

int Member::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Member::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Member*>(&from));
}

void Member::MergeFrom(const Member& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Member::CopyFrom(const Member& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Member::IsInitialized() const {

  return true;
}

void Member::Swap(Member* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Member::GetTypeName() const {
  return "zina.Member";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupUpdateSetName::kUpdateIdFieldNumber;
const int GroupUpdateSetName::kVclockFieldNumber;
const int GroupUpdateSetName::kNameFieldNumber;
#endif  // !_MSC_VER

GroupUpdateSetName::GroupUpdateSetName()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.GroupUpdateSetName)
}

void GroupUpdateSetName::InitAsDefaultInstance() {
}

GroupUpdateSetName::GroupUpdateSetName(const GroupUpdateSetName& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.GroupUpdateSetName)
}

void GroupUpdateSetName::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupUpdateSetName::~GroupUpdateSetName() {
  // @@protoc_insertion_point(destructor:zina.GroupUpdateSetName)
  SharedDtor();
}

void GroupUpdateSetName::SharedDtor() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupUpdateSetName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupUpdateSetName& GroupUpdateSetName::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

GroupUpdateSetName* GroupUpdateSetName::default_instance_ = NULL;

GroupUpdateSetName* GroupUpdateSetName::New() const {
  return new GroupUpdateSetName;
}

void GroupUpdateSetName::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    if (has_update_id()) {
      if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        update_id_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }
  vclock_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupUpdateSetName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.GroupUpdateSetName)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes update_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_update_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vclock;
        break;
      }

      // repeated .zina.VClock vclock = 2;
      case 2: {
        if (tag == 18) {
         parse_vclock:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_vclock()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vclock;
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // optional string name = 3;
      case 3: {
        if (tag == 26) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.GroupUpdateSetName)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.GroupUpdateSetName)
  return false;
#undef DO_
}

void GroupUpdateSetName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.GroupUpdateSetName)
  // optional bytes update_id = 1;
  if (has_update_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->update_id(), output);
  }

  // repeated .zina.VClock vclock = 2;
  for (int i = 0; i < this->vclock_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->vclock(i), output);
  }

  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.GroupUpdateSetName)
}

int GroupUpdateSetName::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes update_id = 1;
    if (has_update_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->update_id());
    }

    // optional string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .zina.VClock vclock = 2;
  total_size += 1 * this->vclock_size();
  for (int i = 0; i < this->vclock_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->vclock(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupUpdateSetName::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupUpdateSetName*>(&from));
}

void GroupUpdateSetName::MergeFrom(const GroupUpdateSetName& from) {
  GOOGLE_CHECK_NE(&from, this);
  vclock_.MergeFrom(from.vclock_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_update_id()) {
      set_update_id(from.update_id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupUpdateSetName::CopyFrom(const GroupUpdateSetName& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupUpdateSetName::IsInitialized() const {

  return true;
}

void GroupUpdateSetName::Swap(GroupUpdateSetName* other) {
  if (other != this) {
    std::swap(update_id_, other->update_id_);
    vclock_.Swap(&other->vclock_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupUpdateSetName::GetTypeName() const {
  return "zina.GroupUpdateSetName";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupUpdateSetAvatar::kUpdateIdFieldNumber;
const int GroupUpdateSetAvatar::kVclockFieldNumber;
const int GroupUpdateSetAvatar::kAvatarFieldNumber;
#endif  // !_MSC_VER

GroupUpdateSetAvatar::GroupUpdateSetAvatar()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.GroupUpdateSetAvatar)
}

void GroupUpdateSetAvatar::InitAsDefaultInstance() {
}

GroupUpdateSetAvatar::GroupUpdateSetAvatar(const GroupUpdateSetAvatar& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.GroupUpdateSetAvatar)
}

void GroupUpdateSetAvatar::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupUpdateSetAvatar::~GroupUpdateSetAvatar() {
  // @@protoc_insertion_point(destructor:zina.GroupUpdateSetAvatar)
  SharedDtor();
}

void GroupUpdateSetAvatar::SharedDtor() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupUpdateSetAvatar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupUpdateSetAvatar& GroupUpdateSetAvatar::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

GroupUpdateSetAvatar* GroupUpdateSetAvatar::default_instance_ = NULL;

GroupUpdateSetAvatar* GroupUpdateSetAvatar::New() const {
  return new GroupUpdateSetAvatar;
}

void GroupUpdateSetAvatar::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    if (has_update_id()) {
      if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        update_id_->clear();
      }
    }
    if (has_avatar()) {
      if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        avatar_->clear();
      }
    }
  }
  vclock_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupUpdateSetAvatar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.GroupUpdateSetAvatar)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes update_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_update_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vclock;
        break;
      }

      // repeated .zina.VClock vclock = 2;
      case 2: {
        if (tag == 18) {
         parse_vclock:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_vclock()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vclock;
        if (input->ExpectTag(26)) goto parse_avatar;
        break;
      }

      // optional string avatar = 3;
      case 3: {
        if (tag == 26) {
         parse_avatar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_avatar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.GroupUpdateSetAvatar)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.GroupUpdateSetAvatar)
  return false;
#undef DO_
}

void GroupUpdateSetAvatar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.GroupUpdateSetAvatar)
  // optional bytes update_id = 1;
  if (has_update_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->update_id(), output);
  }

  // repeated .zina.VClock vclock = 2;
  for (int i = 0; i < this->vclock_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->vclock(i), output);
  }

  // optional string avatar = 3;
  if (has_avatar()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->avatar(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.GroupUpdateSetAvatar)
}

int GroupUpdateSetAvatar::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes update_id = 1;
    if (has_update_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->update_id());
    }

    // optional string avatar = 3;
    if (has_avatar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->avatar());
    }

  }
  // repeated .zina.VClock vclock = 2;
  total_size += 1 * this->vclock_size();
  for (int i = 0; i < this->vclock_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->vclock(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupUpdateSetAvatar::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupUpdateSetAvatar*>(&from));
}

void GroupUpdateSetAvatar::MergeFrom(const GroupUpdateSetAvatar& from) {
  GOOGLE_CHECK_NE(&from, this);
  vclock_.MergeFrom(from.vclock_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_update_id()) {
      set_update_id(from.update_id());
    }
    if (from.has_avatar()) {
      set_avatar(from.avatar());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupUpdateSetAvatar::CopyFrom(const GroupUpdateSetAvatar& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupUpdateSetAvatar::IsInitialized() const {

  return true;
}

void GroupUpdateSetAvatar::Swap(GroupUpdateSetAvatar* other) {
  if (other != this) {
    std::swap(update_id_, other->update_id_);
    vclock_.Swap(&other->vclock_);
    std::swap(avatar_, other->avatar_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupUpdateSetAvatar::GetTypeName() const {
  return "zina.GroupUpdateSetAvatar";
}


// ===================================================================

bool GroupUpdateSetBurn_BurnMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const GroupUpdateSetBurn_BurnMode GroupUpdateSetBurn::BURN_NONE;
const GroupUpdateSetBurn_BurnMode GroupUpdateSetBurn::FROM_SEND_RETROACTIVE;
const GroupUpdateSetBurn_BurnMode GroupUpdateSetBurn::BurnMode_MIN;
const GroupUpdateSetBurn_BurnMode GroupUpdateSetBurn::BurnMode_MAX;
const int GroupUpdateSetBurn::BurnMode_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int GroupUpdateSetBurn::kUpdateIdFieldNumber;
const int GroupUpdateSetBurn::kVclockFieldNumber;
const int GroupUpdateSetBurn::kBurnModeFieldNumber;
const int GroupUpdateSetBurn::kBurnTtlSecFieldNumber;
#endif  // !_MSC_VER

GroupUpdateSetBurn::GroupUpdateSetBurn()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.GroupUpdateSetBurn)
}

void GroupUpdateSetBurn::InitAsDefaultInstance() {
}

GroupUpdateSetBurn::GroupUpdateSetBurn(const GroupUpdateSetBurn& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.GroupUpdateSetBurn)
}

void GroupUpdateSetBurn::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  burn_mode_ = 0;
  burn_ttl_sec_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupUpdateSetBurn::~GroupUpdateSetBurn() {
  // @@protoc_insertion_point(destructor:zina.GroupUpdateSetBurn)
  SharedDtor();
}

void GroupUpdateSetBurn::SharedDtor() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupUpdateSetBurn::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupUpdateSetBurn& GroupUpdateSetBurn::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

GroupUpdateSetBurn* GroupUpdateSetBurn::default_instance_ = NULL;

GroupUpdateSetBurn* GroupUpdateSetBurn::New() const {
  return new GroupUpdateSetBurn;
}

void GroupUpdateSetBurn::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GroupUpdateSetBurn*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 13) {
    ZR_(burn_ttl_sec_, burn_mode_);
    if (has_update_id()) {
      if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        update_id_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  vclock_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupUpdateSetBurn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.GroupUpdateSetBurn)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes update_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_update_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vclock;
        break;
      }

      // repeated .zina.VClock vclock = 2;
      case 2: {
        if (tag == 18) {
         parse_vclock:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_vclock()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vclock;
        if (input->ExpectTag(24)) goto parse_burn_mode;
        break;
      }

      // optional .zina.GroupUpdateSetBurn.BurnMode burn_mode = 3;
      case 3: {
        if (tag == 24) {
         parse_burn_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::zina::GroupUpdateSetBurn_BurnMode_IsValid(value)) {
            set_burn_mode(static_cast< ::zina::GroupUpdateSetBurn_BurnMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_burn_ttl_sec;
        break;
      }

      // optional uint64 burn_ttl_sec = 4;
      case 4: {
        if (tag == 32) {
         parse_burn_ttl_sec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &burn_ttl_sec_)));
          set_has_burn_ttl_sec();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.GroupUpdateSetBurn)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.GroupUpdateSetBurn)
  return false;
#undef DO_
}

void GroupUpdateSetBurn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.GroupUpdateSetBurn)
  // optional bytes update_id = 1;
  if (has_update_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->update_id(), output);
  }

  // repeated .zina.VClock vclock = 2;
  for (int i = 0; i < this->vclock_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->vclock(i), output);
  }

  // optional .zina.GroupUpdateSetBurn.BurnMode burn_mode = 3;
  if (has_burn_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->burn_mode(), output);
  }

  // optional uint64 burn_ttl_sec = 4;
  if (has_burn_ttl_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->burn_ttl_sec(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.GroupUpdateSetBurn)
}

int GroupUpdateSetBurn::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes update_id = 1;
    if (has_update_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->update_id());
    }

    // optional .zina.GroupUpdateSetBurn.BurnMode burn_mode = 3;
    if (has_burn_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->burn_mode());
    }

    // optional uint64 burn_ttl_sec = 4;
    if (has_burn_ttl_sec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->burn_ttl_sec());
    }

  }
  // repeated .zina.VClock vclock = 2;
  total_size += 1 * this->vclock_size();
  for (int i = 0; i < this->vclock_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->vclock(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupUpdateSetBurn::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupUpdateSetBurn*>(&from));
}

void GroupUpdateSetBurn::MergeFrom(const GroupUpdateSetBurn& from) {
  GOOGLE_CHECK_NE(&from, this);
  vclock_.MergeFrom(from.vclock_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_update_id()) {
      set_update_id(from.update_id());
    }
    if (from.has_burn_mode()) {
      set_burn_mode(from.burn_mode());
    }
    if (from.has_burn_ttl_sec()) {
      set_burn_ttl_sec(from.burn_ttl_sec());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupUpdateSetBurn::CopyFrom(const GroupUpdateSetBurn& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupUpdateSetBurn::IsInitialized() const {

  return true;
}

void GroupUpdateSetBurn::Swap(GroupUpdateSetBurn* other) {
  if (other != this) {
    std::swap(update_id_, other->update_id_);
    vclock_.Swap(&other->vclock_);
    std::swap(burn_mode_, other->burn_mode_);
    std::swap(burn_ttl_sec_, other->burn_ttl_sec_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupUpdateSetBurn::GetTypeName() const {
  return "zina.GroupUpdateSetBurn";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupUpdateAddMember::kUpdateIdFieldNumber;
const int GroupUpdateAddMember::kAddMemberFieldNumber;
#endif  // !_MSC_VER

GroupUpdateAddMember::GroupUpdateAddMember()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.GroupUpdateAddMember)
}

void GroupUpdateAddMember::InitAsDefaultInstance() {
}

GroupUpdateAddMember::GroupUpdateAddMember(const GroupUpdateAddMember& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.GroupUpdateAddMember)
}

void GroupUpdateAddMember::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupUpdateAddMember::~GroupUpdateAddMember() {
  // @@protoc_insertion_point(destructor:zina.GroupUpdateAddMember)
  SharedDtor();
}

void GroupUpdateAddMember::SharedDtor() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupUpdateAddMember::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupUpdateAddMember& GroupUpdateAddMember::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

GroupUpdateAddMember* GroupUpdateAddMember::default_instance_ = NULL;

GroupUpdateAddMember* GroupUpdateAddMember::New() const {
  return new GroupUpdateAddMember;
}

void GroupUpdateAddMember::Clear() {
  if (has_update_id()) {
    if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      update_id_->clear();
    }
  }
  addmember_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupUpdateAddMember::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.GroupUpdateAddMember)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes update_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_update_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_addMember;
        break;
      }

      // repeated .zina.Member addMember = 2;
      case 2: {
        if (tag == 18) {
         parse_addMember:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_addmember()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_addMember;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.GroupUpdateAddMember)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.GroupUpdateAddMember)
  return false;
#undef DO_
}

void GroupUpdateAddMember::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.GroupUpdateAddMember)
  // optional bytes update_id = 1;
  if (has_update_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->update_id(), output);
  }

  // repeated .zina.Member addMember = 2;
  for (int i = 0; i < this->addmember_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->addmember(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.GroupUpdateAddMember)
}

int GroupUpdateAddMember::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes update_id = 1;
    if (has_update_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->update_id());
    }

  }
  // repeated .zina.Member addMember = 2;
  total_size += 1 * this->addmember_size();
  for (int i = 0; i < this->addmember_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->addmember(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupUpdateAddMember::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupUpdateAddMember*>(&from));
}

void GroupUpdateAddMember::MergeFrom(const GroupUpdateAddMember& from) {
  GOOGLE_CHECK_NE(&from, this);
  addmember_.MergeFrom(from.addmember_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_update_id()) {
      set_update_id(from.update_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupUpdateAddMember::CopyFrom(const GroupUpdateAddMember& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupUpdateAddMember::IsInitialized() const {

  return true;
}

void GroupUpdateAddMember::Swap(GroupUpdateAddMember* other) {
  if (other != this) {
    std::swap(update_id_, other->update_id_);
    addmember_.Swap(&other->addmember_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupUpdateAddMember::GetTypeName() const {
  return "zina.GroupUpdateAddMember";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupUpdateRmMember::kUpdateIdFieldNumber;
const int GroupUpdateRmMember::kRmMemberFieldNumber;
#endif  // !_MSC_VER

GroupUpdateRmMember::GroupUpdateRmMember()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.GroupUpdateRmMember)
}

void GroupUpdateRmMember::InitAsDefaultInstance() {
}

GroupUpdateRmMember::GroupUpdateRmMember(const GroupUpdateRmMember& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.GroupUpdateRmMember)
}

void GroupUpdateRmMember::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupUpdateRmMember::~GroupUpdateRmMember() {
  // @@protoc_insertion_point(destructor:zina.GroupUpdateRmMember)
  SharedDtor();
}

void GroupUpdateRmMember::SharedDtor() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupUpdateRmMember::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupUpdateRmMember& GroupUpdateRmMember::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

GroupUpdateRmMember* GroupUpdateRmMember::default_instance_ = NULL;

GroupUpdateRmMember* GroupUpdateRmMember::New() const {
  return new GroupUpdateRmMember;
}

void GroupUpdateRmMember::Clear() {
  if (has_update_id()) {
    if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      update_id_->clear();
    }
  }
  rmmember_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupUpdateRmMember::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.GroupUpdateRmMember)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes update_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_update_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_rmMember;
        break;
      }

      // repeated .zina.Member rmMember = 2;
      case 2: {
        if (tag == 18) {
         parse_rmMember:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rmmember()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_rmMember;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.GroupUpdateRmMember)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.GroupUpdateRmMember)
  return false;
#undef DO_
}

void GroupUpdateRmMember::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.GroupUpdateRmMember)
  // optional bytes update_id = 1;
  if (has_update_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->update_id(), output);
  }

  // repeated .zina.Member rmMember = 2;
  for (int i = 0; i < this->rmmember_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->rmmember(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.GroupUpdateRmMember)
}

int GroupUpdateRmMember::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes update_id = 1;
    if (has_update_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->update_id());
    }

  }
  // repeated .zina.Member rmMember = 2;
  total_size += 1 * this->rmmember_size();
  for (int i = 0; i < this->rmmember_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rmmember(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupUpdateRmMember::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupUpdateRmMember*>(&from));
}

void GroupUpdateRmMember::MergeFrom(const GroupUpdateRmMember& from) {
  GOOGLE_CHECK_NE(&from, this);
  rmmember_.MergeFrom(from.rmmember_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_update_id()) {
      set_update_id(from.update_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupUpdateRmMember::CopyFrom(const GroupUpdateRmMember& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupUpdateRmMember::IsInitialized() const {

  return true;
}

void GroupUpdateRmMember::Swap(GroupUpdateRmMember* other) {
  if (other != this) {
    std::swap(update_id_, other->update_id_);
    rmmember_.Swap(&other->rmmember_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupUpdateRmMember::GetTypeName() const {
  return "zina.GroupUpdateRmMember";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupBurnMessage::kUpdateIdFieldNumber;
const int GroupBurnMessage::kMsgIdFieldNumber;
const int GroupBurnMessage::kMemberFieldNumber;
#endif  // !_MSC_VER

GroupBurnMessage::GroupBurnMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.GroupBurnMessage)
}

void GroupBurnMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  member_ = const_cast< ::zina::Member*>(
      ::zina::Member::internal_default_instance());
#else
  member_ = const_cast< ::zina::Member*>(&::zina::Member::default_instance());
#endif
}

GroupBurnMessage::GroupBurnMessage(const GroupBurnMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.GroupBurnMessage)
}

void GroupBurnMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  member_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupBurnMessage::~GroupBurnMessage() {
  // @@protoc_insertion_point(destructor:zina.GroupBurnMessage)
  SharedDtor();
}

void GroupBurnMessage::SharedDtor() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete member_;
  }
}

void GroupBurnMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupBurnMessage& GroupBurnMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

GroupBurnMessage* GroupBurnMessage::default_instance_ = NULL;

GroupBurnMessage* GroupBurnMessage::New() const {
  return new GroupBurnMessage;
}

void GroupBurnMessage::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    if (has_update_id()) {
      if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        update_id_->clear();
      }
    }
    if (has_member()) {
      if (member_ != NULL) member_->::zina::Member::Clear();
    }
  }
  msgid_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupBurnMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.GroupBurnMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes update_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_update_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_msgId;
        break;
      }

      // repeated string msgId = 2;
      case 2: {
        if (tag == 18) {
         parse_msgId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_msgid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_msgId;
        if (input->ExpectTag(26)) goto parse_member;
        break;
      }

      // optional .zina.Member member = 3;
      case 3: {
        if (tag == 26) {
         parse_member:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_member()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.GroupBurnMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.GroupBurnMessage)
  return false;
#undef DO_
}

void GroupBurnMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.GroupBurnMessage)
  // optional bytes update_id = 1;
  if (has_update_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->update_id(), output);
  }

  // repeated string msgId = 2;
  for (int i = 0; i < this->msgid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->msgid(i), output);
  }

  // optional .zina.Member member = 3;
  if (has_member()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->member(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.GroupBurnMessage)
}

int GroupBurnMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes update_id = 1;
    if (has_update_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->update_id());
    }

    // optional .zina.Member member = 3;
    if (has_member()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->member());
    }

  }
  // repeated string msgId = 2;
  total_size += 1 * this->msgid_size();
  for (int i = 0; i < this->msgid_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->msgid(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupBurnMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupBurnMessage*>(&from));
}

void GroupBurnMessage::MergeFrom(const GroupBurnMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  msgid_.MergeFrom(from.msgid_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_update_id()) {
      set_update_id(from.update_id());
    }
    if (from.has_member()) {
      mutable_member()->::zina::Member::MergeFrom(from.member());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupBurnMessage::CopyFrom(const GroupBurnMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupBurnMessage::IsInitialized() const {

  return true;
}

void GroupBurnMessage::Swap(GroupBurnMessage* other) {
  if (other != this) {
    std::swap(update_id_, other->update_id_);
    msgid_.Swap(&other->msgid_);
    std::swap(member_, other->member_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupBurnMessage::GetTypeName() const {
  return "zina.GroupBurnMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupUpdateAck::kTypeFieldNumber;
const int GroupUpdateAck::kUpdateIdFieldNumber;
const int GroupUpdateAck::kResultFieldNumber;
#endif  // !_MSC_VER

GroupUpdateAck::GroupUpdateAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.GroupUpdateAck)
}

void GroupUpdateAck::InitAsDefaultInstance() {
}

GroupUpdateAck::GroupUpdateAck(const GroupUpdateAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.GroupUpdateAck)
}

void GroupUpdateAck::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 0;
  update_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupUpdateAck::~GroupUpdateAck() {
  // @@protoc_insertion_point(destructor:zina.GroupUpdateAck)
  SharedDtor();
}

void GroupUpdateAck::SharedDtor() {
  if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete update_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupUpdateAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupUpdateAck& GroupUpdateAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

GroupUpdateAck* GroupUpdateAck::default_instance_ = NULL;

GroupUpdateAck* GroupUpdateAck::New() const {
  return new GroupUpdateAck;
}

void GroupUpdateAck::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GroupUpdateAck*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(type_, result_);
    if (has_update_id()) {
      if (update_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        update_id_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupUpdateAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.GroupUpdateAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .zina.GroupUpdateType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::zina::GroupUpdateType_IsValid(value)) {
            set_type(static_cast< ::zina::GroupUpdateType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_update_id;
        break;
      }

      // optional bytes update_id = 2;
      case 2: {
        if (tag == 18) {
         parse_update_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_update_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_result;
        break;
      }

      // optional .zina.GroupUpdateResult result = 3;
      case 3: {
        if (tag == 24) {
         parse_result:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::zina::GroupUpdateResult_IsValid(value)) {
            set_result(static_cast< ::zina::GroupUpdateResult >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.GroupUpdateAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.GroupUpdateAck)
  return false;
#undef DO_
}

void GroupUpdateAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.GroupUpdateAck)
  // optional .zina.GroupUpdateType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional bytes update_id = 2;
  if (has_update_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->update_id(), output);
  }

  // optional .zina.GroupUpdateResult result = 3;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.GroupUpdateAck)
}

int GroupUpdateAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .zina.GroupUpdateType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional bytes update_id = 2;
    if (has_update_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->update_id());
    }

    // optional .zina.GroupUpdateResult result = 3;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupUpdateAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupUpdateAck*>(&from));
}

void GroupUpdateAck::MergeFrom(const GroupUpdateAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_update_id()) {
      set_update_id(from.update_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupUpdateAck::CopyFrom(const GroupUpdateAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupUpdateAck::IsInitialized() const {

  return true;
}

void GroupUpdateAck::Swap(GroupUpdateAck* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(update_id_, other->update_id_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupUpdateAck::GetTypeName() const {
  return "zina.GroupUpdateAck";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupChangeSet::kGroupIdFieldNumber;
const int GroupChangeSet::kUpdateNameFieldNumber;
const int GroupChangeSet::kUpdateAvatarFieldNumber;
const int GroupChangeSet::kUpdateBurnFieldNumber;
const int GroupChangeSet::kUpdateAddMemberFieldNumber;
const int GroupChangeSet::kUpdateRmMemberFieldNumber;
const int GroupChangeSet::kBurnMessageFieldNumber;
const int GroupChangeSet::kAcksFieldNumber;
#endif  // !_MSC_VER

GroupChangeSet::GroupChangeSet()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zina.GroupChangeSet)
}

void GroupChangeSet::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  updatename_ = const_cast< ::zina::GroupUpdateSetName*>(
      ::zina::GroupUpdateSetName::internal_default_instance());
#else
  updatename_ = const_cast< ::zina::GroupUpdateSetName*>(&::zina::GroupUpdateSetName::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  updateavatar_ = const_cast< ::zina::GroupUpdateSetAvatar*>(
      ::zina::GroupUpdateSetAvatar::internal_default_instance());
#else
  updateavatar_ = const_cast< ::zina::GroupUpdateSetAvatar*>(&::zina::GroupUpdateSetAvatar::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  updateburn_ = const_cast< ::zina::GroupUpdateSetBurn*>(
      ::zina::GroupUpdateSetBurn::internal_default_instance());
#else
  updateburn_ = const_cast< ::zina::GroupUpdateSetBurn*>(&::zina::GroupUpdateSetBurn::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  updateaddmember_ = const_cast< ::zina::GroupUpdateAddMember*>(
      ::zina::GroupUpdateAddMember::internal_default_instance());
#else
  updateaddmember_ = const_cast< ::zina::GroupUpdateAddMember*>(&::zina::GroupUpdateAddMember::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  updatermmember_ = const_cast< ::zina::GroupUpdateRmMember*>(
      ::zina::GroupUpdateRmMember::internal_default_instance());
#else
  updatermmember_ = const_cast< ::zina::GroupUpdateRmMember*>(&::zina::GroupUpdateRmMember::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  burnmessage_ = const_cast< ::zina::GroupBurnMessage*>(
      ::zina::GroupBurnMessage::internal_default_instance());
#else
  burnmessage_ = const_cast< ::zina::GroupBurnMessage*>(&::zina::GroupBurnMessage::default_instance());
#endif
}

GroupChangeSet::GroupChangeSet(const GroupChangeSet& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zina.GroupChangeSet)
}

void GroupChangeSet::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  updatename_ = NULL;
  updateavatar_ = NULL;
  updateburn_ = NULL;
  updateaddmember_ = NULL;
  updatermmember_ = NULL;
  burnmessage_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupChangeSet::~GroupChangeSet() {
  // @@protoc_insertion_point(destructor:zina.GroupChangeSet)
  SharedDtor();
}

void GroupChangeSet::SharedDtor() {
  if (group_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete updatename_;
    delete updateavatar_;
    delete updateburn_;
    delete updateaddmember_;
    delete updatermmember_;
    delete burnmessage_;
  }
}

void GroupChangeSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupChangeSet& GroupChangeSet::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GroupProtocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GroupProtocol_2eproto();
#endif
  return *default_instance_;
}

GroupChangeSet* GroupChangeSet::default_instance_ = NULL;

GroupChangeSet* GroupChangeSet::New() const {
  return new GroupChangeSet;
}

void GroupChangeSet::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    if (has_group_id()) {
      if (group_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        group_id_->clear();
      }
    }
    if (has_updatename()) {
      if (updatename_ != NULL) updatename_->::zina::GroupUpdateSetName::Clear();
    }
    if (has_updateavatar()) {
      if (updateavatar_ != NULL) updateavatar_->::zina::GroupUpdateSetAvatar::Clear();
    }
    if (has_updateburn()) {
      if (updateburn_ != NULL) updateburn_->::zina::GroupUpdateSetBurn::Clear();
    }
    if (has_updateaddmember()) {
      if (updateaddmember_ != NULL) updateaddmember_->::zina::GroupUpdateAddMember::Clear();
    }
    if (has_updatermmember()) {
      if (updatermmember_ != NULL) updatermmember_->::zina::GroupUpdateRmMember::Clear();
    }
    if (has_burnmessage()) {
      if (burnmessage_ != NULL) burnmessage_->::zina::GroupBurnMessage::Clear();
    }
  }
  acks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupChangeSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:zina.GroupChangeSet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes group_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_group_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_updateName;
        break;
      }

      // optional .zina.GroupUpdateSetName updateName = 2;
      case 2: {
        if (tag == 18) {
         parse_updateName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_updatename()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_updateAvatar;
        break;
      }

      // optional .zina.GroupUpdateSetAvatar updateAvatar = 3;
      case 3: {
        if (tag == 26) {
         parse_updateAvatar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_updateavatar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_updateBurn;
        break;
      }

      // optional .zina.GroupUpdateSetBurn updateBurn = 4;
      case 4: {
        if (tag == 34) {
         parse_updateBurn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_updateburn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_updateAddMember;
        break;
      }

      // optional .zina.GroupUpdateAddMember updateAddMember = 5;
      case 5: {
        if (tag == 42) {
         parse_updateAddMember:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_updateaddmember()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_updateRmMember;
        break;
      }

      // optional .zina.GroupUpdateRmMember updateRmMember = 6;
      case 6: {
        if (tag == 50) {
         parse_updateRmMember:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_updatermmember()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_acks;
        break;
      }

      // repeated .zina.GroupUpdateAck acks = 7;
      case 7: {
        if (tag == 58) {
         parse_acks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_acks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_acks;
        if (input->ExpectTag(66)) goto parse_burnMessage;
        break;
      }

      // optional .zina.GroupBurnMessage burnMessage = 8;
      case 8: {
        if (tag == 66) {
         parse_burnMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_burnmessage()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zina.GroupChangeSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zina.GroupChangeSet)
  return false;
#undef DO_
}

void GroupChangeSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zina.GroupChangeSet)
  // optional bytes group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->group_id(), output);
  }

  // optional .zina.GroupUpdateSetName updateName = 2;
  if (has_updatename()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->updatename(), output);
  }

  // optional .zina.GroupUpdateSetAvatar updateAvatar = 3;
  if (has_updateavatar()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->updateavatar(), output);
  }

  // optional .zina.GroupUpdateSetBurn updateBurn = 4;
  if (has_updateburn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->updateburn(), output);
  }

  // optional .zina.GroupUpdateAddMember updateAddMember = 5;
  if (has_updateaddmember()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->updateaddmember(), output);
  }

  // optional .zina.GroupUpdateRmMember updateRmMember = 6;
  if (has_updatermmember()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->updatermmember(), output);
  }

  // repeated .zina.GroupUpdateAck acks = 7;
  for (int i = 0; i < this->acks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->acks(i), output);
  }

  // optional .zina.GroupBurnMessage burnMessage = 8;
  if (has_burnmessage()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->burnmessage(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:zina.GroupChangeSet)
}

int GroupChangeSet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->group_id());
    }

    // optional .zina.GroupUpdateSetName updateName = 2;
    if (has_updatename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->updatename());
    }

    // optional .zina.GroupUpdateSetAvatar updateAvatar = 3;
    if (has_updateavatar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->updateavatar());
    }

    // optional .zina.GroupUpdateSetBurn updateBurn = 4;
    if (has_updateburn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->updateburn());
    }

    // optional .zina.GroupUpdateAddMember updateAddMember = 5;
    if (has_updateaddmember()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->updateaddmember());
    }

    // optional .zina.GroupUpdateRmMember updateRmMember = 6;
    if (has_updatermmember()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->updatermmember());
    }

    // optional .zina.GroupBurnMessage burnMessage = 8;
    if (has_burnmessage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->burnmessage());
    }

  }
  // repeated .zina.GroupUpdateAck acks = 7;
  total_size += 1 * this->acks_size();
  for (int i = 0; i < this->acks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->acks(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupChangeSet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupChangeSet*>(&from));
}

void GroupChangeSet::MergeFrom(const GroupChangeSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  acks_.MergeFrom(from.acks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_updatename()) {
      mutable_updatename()->::zina::GroupUpdateSetName::MergeFrom(from.updatename());
    }
    if (from.has_updateavatar()) {
      mutable_updateavatar()->::zina::GroupUpdateSetAvatar::MergeFrom(from.updateavatar());
    }
    if (from.has_updateburn()) {
      mutable_updateburn()->::zina::GroupUpdateSetBurn::MergeFrom(from.updateburn());
    }
    if (from.has_updateaddmember()) {
      mutable_updateaddmember()->::zina::GroupUpdateAddMember::MergeFrom(from.updateaddmember());
    }
    if (from.has_updatermmember()) {
      mutable_updatermmember()->::zina::GroupUpdateRmMember::MergeFrom(from.updatermmember());
    }
    if (from.has_burnmessage()) {
      mutable_burnmessage()->::zina::GroupBurnMessage::MergeFrom(from.burnmessage());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupChangeSet::CopyFrom(const GroupChangeSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupChangeSet::IsInitialized() const {

  return true;
}

void GroupChangeSet::Swap(GroupChangeSet* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    std::swap(updatename_, other->updatename_);
    std::swap(updateavatar_, other->updateavatar_);
    std::swap(updateburn_, other->updateburn_);
    std::swap(updateaddmember_, other->updateaddmember_);
    std::swap(updatermmember_, other->updatermmember_);
    std::swap(burnmessage_, other->burnmessage_);
    acks_.Swap(&other->acks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupChangeSet::GetTypeName() const {
  return "zina.GroupChangeSet";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace zina

// @@protoc_insertion_point(global_scope)
